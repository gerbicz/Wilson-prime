/* 
Fast code to get (p-1)! mod p^2 simultaneously for several p values 
2011-2012, written by Robert Gerbicz
polynomial gcd algorithm and code in Sage/Pari-GP from David Harvey
ntt library from David Harvey
ideas from Edgar Costa
invert routine (mpn_invert2) from Paul Zimmermann, slightly modified.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/

// Add -fopenmp as flag to use OpenMp
//     -lm

// A totally brute force code:
// F(p)=r=Mod(1,p*p);for(i=1,p-1,r*=i);return(lift(r))

// my long compilation line:
// gcc -fopenmp -m64 -fgnu89-inline -std=c99 -O2 -lgmp -lm -Wall -o pw13 pw13.c profile.c misc.c modarith.c memory.c fft_main.c fft_base.c fft_array.c intmult.c tunetab.c -I/home/gerbicz/gmp-5.0.2 -L/home/gerbicz/gmp-5.0.2

// some lines: (verified by slow wilsonremainder() function)
// p      (p-1)! mod p*p
// 999979 496398575410
// 999983 285106153112
// 9999973 43866321560611
// 9999991 10433100610200
// 100000007 2797130195799099
// 1000000007 248930608742514248 ( 57 sec. )
// 10000000019 1104594712098729948 ( 634 sec. )
// 10000000033 43243222192702632764
// 10000000061 23299102792124526164
// 10000000069 69886760102218641377
// 10000000097 50793644052698342531
// 10000000103 11469982338140816865
// 10000000121 65303769910175606351
// 10000000141 31024748547448948350
// 10000000147 57730848208643456191
// 10000000207 61378175160528199522
// 10000000259 32074431130727744769
// 10000000277 42942022099493979206
// 10000000279 43120855923071846687
// 10000000319 17819587048444808711
// 10000000343 76154581452102054211
// 10000000391 99209804339103197985
// 10000000403 25979094576957469258
// 10000000469 879234071236076006
// 10000000501 60803870386273753733
// 10000000537 19695429747644520652

// some other useful data: (here 1k=1000,1M=10^6,1B=10^9,1T=10^12)
// primepi(25k)=2762
// primepi(50k)=5133
// primepi(100k)=9592
// primepi(1M)=78498
// primepi(10M)=664579
// primepi(25M)=1565927
// primepi(50M)=3001334
// primepi(500M)=26355867

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <string.h>
#include <sys/time.h>
#include <time.h>
#include "gmp-5.0.4/gmp.h" // or use mpir!
#include "gmp-5.0.4/gmp-impl.h"
#include "omp.h"
#include "gmp-5.0.4/longlong.h"
#include "ntt-0.1.2/ntt.h"
#include "ntt-0.1.2/ntt-internal.h"

#ifdef __unix__
#include <unistd.h>
#endif

#define MUL_TRESHOLD tune_tab[1] // FFT treshold on a single core (using ntt library)
#define BARRETT1_TRESHOLD 200 // below this size (in limbs) we use division in gmp,mpir
#define max_d 24
#define max_e 90
#define precision_in_bits 128
#define LOG2 0.6931471805599453094172321214581765680755L
#define PI "3.141592653589793238462643383279502884197"
#define max_iterations 1000
#define max_iterations_in_c 20000
#define max_exponent 16
#define block_eps 0.3
#define block_eps2 0.999
#define BIG_PRIME 31862344740937LL
#define PRIMITIVE_ROOT 7927
// 7927 is a primitive root modulo 31862344740937

#define bound 100
#define denom 5000
// print out all solutions, where (p-1)! == -1+k*p mod p^2 for abs(k)<=max(bound,p/denom)
#define chunk_size 10000 // in the 3rd stage
int save_res;// if save_res=1, then use large savefiles
#define seconds_per_save 1800 // time in seconds to save residues
#define seconds_per_save_stage3 300 // in the 3rd stage the update is faster
time_t max_wall_time; // spend at most this time on computation
#define extra_time 40 // in seconds
#define POWER2 1024 // it should be at least cores
#define SPOWER2 256 // used only in the 2nd stage, the optimal value is somewhere 8*cores to keep the memory low in this stage
#define ONE (mp_limb_t)1
#define ZERO (mp_limb_t)0
#define enable_parallel_for_easy_func 1 // parallel sub/add/shift etc., set 0 to disable these parallel stuffs
#define TRESHOLD_FOR_EASY_PARALLEL 1000000 // in limbs
#define maxsol 10000 // it is totally safe to use maxsol=chunk_size,
                     // in general it is also safe to use
                     // maxsol>>2*interval/denom to avoid segmentation fault
#define step_depth 4 // used these two depths to balance the memory/speed in the 2nd stage
#define ext_depth 2
#define enable_schedule_3power2 1 // if it is zero then disable the scheduling algorithm (for 3*2^n cores) in prodtree2() 
#define OUT_SIZE 65536LL // in bytes

#define test_all_primes_for_e 0
// if it is non-zero then we test for 'interval' consecutive primes (p==1 mod e)
// and this results that we test the same prime for multiple e values

#define num_type 1 // number of different computer types
// same type of computer means that these has got the same Ram, speed and number of cores.

// during run of 'interval' primes don't change these values, otherwise the result can be totally corrupt!
// and don't modify parallelwilsonwork.txt



typedef long long int lli;
// lli *precomputed;

int existplist;
lli max_ui=0,interval,*plist,*pow1024;// pow1024[i]=floor(2^(i/1024))
int *numsol,*numsol2,*prime,primepi,printtofile,sievelen,stage1_f1,stage2_f21,stage2_f22,stage2_f23,stage3_f3;
mpz_t **saved_p,**saved_p2,**saved_r,**saved_r2;
time_t time_of_last_save,start_time;
time_t used_cpu_clock_time,used_wall_time,used_stage_cpu_clock_time,used_stage_wall_time;
time_t start_stage_cpu_clock_time,start_stage_wall_time;

mpf_t smalleps; // 1/2^precision_in_bits

int iigcd(int,int);
int eulerphi(int);
lli imin(lli,lli);
lli imax(lli,lli);
lli iabs(lli);
int valid_even_e(int);
lli getrandom(lli);
long double mpf_to_longdouble(mpf_t);
void longlongtompz(mpz_ptr,lli);
lli mpztolonglong(mpz_t);
void inits(void);
void del(void);
void init_tables(int,int);
void c_init_tables(int,int);
void setup_l(int);
void setup_R(int);
void setup_U1_U2(void);
void setup_MM(int,int);
void sin_f(mpf_ptr,mpf_t);
void cos_f(mpf_ptr,mpf_t);
void conjugate(mpz_t[],mpz_t[],int,int,int);
void setup_SS(int,int);
void setup_SS2(int,int);
void c_general_reduce_f(long double[],int,int,int);
void c_general_reduce_z(lli[],int,int,int);
void reduce_f(mpf_t[],int,int);
void c_reduce_f(long double[],int,int);
void reduce_z(mpz_t[],int,int);
void c_reduce_z(lli[],int,int);
void bigreduce_f(mpf_t[],int,int);
void c_bigreduce_f(long double[],int,int);
void bigreduce_z(mpz_t[],int,int);
void c_bigreduce_z(lli[],int,int);
void sub_z(mpz_t[],mpz_t[],mpz_t[],int);
void c_sub_z(lli[],lli[],lli[],int);
void mul_z(mpz_t[],mpz_t[],mpz_t[],int,int);
void c_mul_z(lli[],lli[],lli[],int,int);
void embed_f(mpf_t[][2],mpf_t[],int,int);
void c_embed_f(long double[][2],long double[],int,int);
void embed_z(mpf_t[][2],mpz_t[],int,int);
void c_embed_z(long double[][2],lli[],int,int);
void unembed_f(mpf_t[],mpf_t[][2],int,int);
void c_unembed_f(long double[],long double[][2],int,int);
void balance(mpz_t[],int,int);
void c_balance(lli[],int,int);
void prodnorm_f(mpf_ptr,mpf_t[][2],int);
long double c_prodnorm_f(long double[][2],int);
void swap_multi_arrays_f(mpf_t[][2],mpf_t[][2],int);
void c_swap_multi_arrays_f(long double[][2],long double[][2],int);
void swap_arrays_z(mpz_t[],mpz_t[],int);
void c_swap_arrays_z(lli[],lli[],int);
void set_arrays_f(mpf_t[],mpf_t[],int);
void c_set_arrays_f(long double[],long double[],int);
void set_arrays_z(mpz_t[],mpz_t[],int);
void c_set_arrays_z(lli[],lli[],int);
void set_multi_arrays_f(mpf_t[][2],mpf_t[][2],int);
void c_set_multi_arrays_f(long double[][2],long double[][2],int);
void abs_complex_f(mpf_ptr,mpf_t,mpf_t);
long double c_abs_complex_f(long double,long double);
void abs_complex_z(mpf_ptr,mpz_t,mpz_t);
long double c_abs_complex_z(lli,lli);
void norm_complex_f(mpf_ptr,mpf_t,mpf_t);
long double c_norm_complex_f(long double,long double);
void div_complex(mpf_ptr,mpf_ptr,mpf_t,mpf_t,mpf_t,mpf_t);
void c_div_complex(long double*,long double*,long double,long double,long double,long double);
double log_f(mpf_t);
void pol_norm_z(mpf_ptr,mpz_t[],int,int);
int pol_gcd(mpz_t[],mpz_t[],mpz_t[],lli,int,int,int,int,lli,int);
int c_pol_gcd(lli[],lli[],lli[],lli,int,int,int,int,lli,int);
void generator(mpz_t[],mpz_ptr,int,int,lli,int,int);
void ratio(mpz_ptr,lli,int,int);
void use_ratio(mpz_ptr,lli,int,int,mpz_t,mpz_t);
void mpz_copy(mpz_t,mpz_t,mp_size_t);
void wilsonremainder(mpz_ptr,mpz_t);
lli wilson21(lli);
lli factorialp(lli,lli);
void initprimes(int);
lli wheelsieve(int,lli,lli,int);
void setuppow1024(void);
void mpn_copyi(mp_ptr,mp_srcptr,mp_size_t);
void mpn_zero(mp_ptr,mp_size_t);
void mpn_com(mp_ptr,mp_srcptr,mp_size_t);
mp_limb_t my_mpn_add_n(mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_size_t,int);
mp_limb_t my_mpn_sub_n(mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_size_t,int);
void my_mpn_copyi(mp_limb_t*,mp_limb_t*,mp_size_t,int);
mp_limb_t my_mpn_rshift(mp_limb_t*,mp_limb_t*,mp_size_t,int,int);
mp_limb_t my_mpn_lshift(mp_limb_t*,mp_limb_t*,mp_size_t,int,int);
void my_mpn_zero(mp_limb_t*,mp_size_t,int);
int bs(lli);
lli get_num_limbs(lli*,lli,lli);
int is_it_on_tree(lli,lli,int);
lli getpos(lli,lli,int);
mp_size_t prodtree(mp_limb_t*,lli*,lli,lli,mp_limb_t*,mp_size_t*,mp_limb_t*);
mp_size_t prodtree2(mp_limb_t*,lli*,lli,lli,int,int);
mp_size_t shift_m(mp_limb_t*,mp_size_t,int);
void mpn_setup_barrett(mp_limb_t*,mp_limb_t*,mp_size_t,int);
mp_limb_t my_invert_limb(mp_limb_t);
void mpn_invert2 (mp_limb_t*,mp_limb_t*,mp_size_t,int);
void mpn_barrett1(mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_size_t,int);
void test_barrett1(void);
void mpn_barrett2(mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_size_t,int);
void mpn_barrett3(mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_limb_t*,mp_size_t,int,int);
void testfun(void);
void write_mpn(FILE*,mp_limb_t*,mp_size_t,int); 
void read_mpn(FILE*,mp_limb_t*,lli,int);
mp_size_t ff(mp_limb_t*,mp_size_t,lli,int,lli,int);
void find_opt_bounds(void);
void timings_of_pol_gcd(void);
void write_mpn_array(FILE*,lli,int,int);
void read_mpn_array(FILE*,lli,int,int);
mp_size_t longdivision(mp_limb_t*,mp_size_t,mp_limb_t*,mp_limb_t*,mp_size_t,mp_ptr,int);
void test_longdivision(void);
void ss(lli,mp_limb_t*,mp_size_t,lli);
lli getpr(lli,int);
void reconstruct(lli*,lli,lli,int);
void fun1(lli,lli,lli,lli,lli,int,int,int,int,lli,lli,int);
void fun2(lli,lli,lli,lli,lli,int,int,int,int,lli,lli,int);
void parallel_func2(mp_size_t,lli*,lli,int,int,lli,lli,lli,int);
mp_size_t mpn_parallel_modproduct_tree(mp_limb_t*,mp_size_t,mp_limb_t*,mp_size_t,mp_limb_t*,lli,lli,int);
void stage3(lli,lli,int,int);
void printwilson(int);
void printallres(int);
void printtime(void);
void usesavefile(void);
void updatesavefile(void);
void save_stage1(int,lli,mp_limb_t*,mp_limb_t*,mp_size_t,int);
mp_size_t read_stage2_res(mp_limb_t*,mp_size_t,int);
void save_stage2_res(mp_limb_t*,mp_size_t,int);
void save_stage2(int,int,lli,lli,lli,lli,lli,int);
void save_stage3_first(lli);
void save_stage3(lli);
void read_stage3(lli);
void get_more_info(void);
double approx_prime_pi(lli);
double get_ratio_stage1(lli,int,lli);
void check_time(void);
void updatetimes(void);

int length_U1,len_SS,NS,polcyclo[max_d+1],l_array[max_e];
mpz_t U1[max_d/2-1][max_d],U2[max_d/2-1][max_d],S[max_d],SS[max_d][max_d],SS2[max_d][max_d];
lli c_U1[max_d/2-1][max_d],c_U2[max_d/2-1][max_d],c_S[max_d],c_SS[max_d][max_d],c_SS2[max_d][max_d];
mpz_t U1pow[max_d/2-1][max_exponent+1][max_d];
lli c_U1pow[max_d/2-1][max_exponent+1][max_d];
mpz_t U2pow[max_d/2-1][max_exponent+1][max_d];
lli c_U2pow[max_d/2-1][max_exponent+1][max_d];
mpf_t R_array[max_e][2];
long double c_R_array[max_e][2];
double MM[max_d/2-1][max_d/2];

int iigcd(int x,int y){if(y==0)return x;return iigcd(y,x%y);}
int eulerphi(int n){int i,ret=0;for(i=1;i<=n;i++)ret+=(iigcd(i,n)==1);return ret;}
lli imin(lli x,lli y){if(x<y)return x;return y;}
lli imax(lli x,lli y){if(x<y)return y;return x;}
lli iabs(lli x){if(x>0)return x;return -x;}

int i_mul_l_array[max_e][max_d];// i_mul_l_array[i][j]=(i*l_array[j])%e

int allowed[]={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24,
 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 40, 42, 44, 45, 48, 50, 54, 60, 66, 70, 84, 90};

int allowed_even_e_values[30]={2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,48,50,54,60,66,70,84,90};

int valid_even_e(int e){int i;for(i=0;i<30;i++)if(allowed_even_e_values[i]==e)return 1;return 0;}

// out-of-date
lli treshold_for_e[30]={3LL,
394390885188LL,
384531113058LL,
815074496056LL,
575153374233LL,
1498685363716LL,
812883435582LL,
4522348816827LL,
2425503943908LL,
5915863277826LL,
1561787905346LL,
7808939526730LL,
2114921121822LL,
18128834355828LL,
6408851884312LL,
43120070113935LL,
3925010955302LL,
25083260297984LL,
5446611159801LL,
53768624014022LL,
17530674846625LL,
127835232252410LL,
66730937773882LL,
41328878177037LL,
61406660823838LL,
87357581069237LL,
99347063978965LL,
122795245398773LL,
505766871165644LL,
288694127957931LL};

int precomputed_NS[]={2, 3, 7, 5, 11, 7, 29, 17, 19, 11, 23, 13, 53, 29, 31, 17, 103, 19, 191, 41, 43, 23,
 73, 101, 53, 109, 29, 31, 97, 67, 103, 71, 37, 191, 41, 43, 89, 181, 97, 101, 109, 61, 67, 71, 337, 181};

int number_of_mults[33]={0,1,3,5,7,9,11,13,17,19,29,37,43,57,65,79,94,
109,131,154,177,206,233,264,293,330,374,420,459,518,562,626,686};

typedef struct {
	long secs;
	long usecs;
} TIME_DIFF;

TIME_DIFF * my_difftime (struct timeval *, struct timeval *);

TIME_DIFF * my_difftime (struct timeval * start, struct timeval * end)
{
	TIME_DIFF * diff = (TIME_DIFF *) malloc ( sizeof (TIME_DIFF) );

	if (start->tv_sec == end->tv_sec) {
		diff->secs = 0;
		diff->usecs = end->tv_usec - start->tv_usec;
	}
	else {
		diff->usecs = 1000000 - start->tv_usec;
		diff->secs = end->tv_sec - (start->tv_sec + 1);
		diff->usecs += end->tv_usec;
		if (diff->usecs >= 1000000) {
			diff->usecs -= 1000000;
			diff->secs += 1;
		}
	}
	
	return diff;
}

int precomputed_polcyclo[][max_d+1]={{-1,1},
{1,1},
{1,1,1},
{1,0,1},
{1,1,1,1,1},
{1,-1,1},
{1,1,1,1,1,1,1},
{1,0,0,0,1},
{1,0,0,1,0,0,1},
{1,-1,1,-1,1},
{1,1,1,1,1,1,1,1,1,1,1},
{1,0,-1,0,1},
{1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,-1,1,-1,1,-1,1},
{1,-1,0,1,-1,1,0,-1,1},
{1,0,0,0,0,0,0,0,1},
{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,0,0,-1,0,0,1},
{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,0,-1,0,1,0,-1,0,1},
{1,-1,0,1,-1,0,1,0,-1,1,0,-1,1},
{1,-1,1,-1,1,-1,1,-1,1,-1,1},
{1,0,0,0,-1,0,0,0,1},
{1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1},
{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1},
{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
{1,0,-1,0,1,0,-1,0,1,0,-1,0,1},
{1,1,0,-1,-1,-1,0,1,1},
{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
{1,-1,0,1,-1,0,1,-1,0,1,-1,1,0,-1,1,0,-1,1,0,-1,1},
{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1},
{1,-1,0,0,0,1,-1,1,-1,0,1,-1,1,-1,1,0,-1,1,-1,1,0,0,0,-1,1},
{1,0,0,0,0,0,-1,0,0,0,0,0,1},
{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1},
{1,0,0,0,-1,0,0,0,1,0,0,0,-1,0,0,0,1},
{1,1,0,-1,-1,0,1,0,-1,-1,0,1,1},
{1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1},
{1,0,0,-1,0,0,0,0,0,1,0,0,-1,0,0,1,0,0,0,0,0,-1,0,0,1},
{1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,1},
{1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1},
{1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,1},
{1,0,1,0,0,0,-1,0,-1,0,-1,0,0,0,1,0,1},
{1,1,0,-1,-1,0,1,1,0,-1,-1,-1,0,1,1,0,-1,-1,0,1,1},
{1,1,0,0,0,-1,-1,-1,-1,0,1,1,1,1,1,0,-1,-1,-1,-1,0,0,0,1,1},
{1,0,1,0,0,0,-1,0,-1,0,0,0,1,0,0,0,-1,0,-1,0,0,0,1,0,1},
{1,0,0,1,0,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,0,1,0,0,1}};

int precomputed_S[][max_d]={{},
{3},
{3,1},
{2,1},
{1,2,0,1},
{2,1},
{1,0,1,0,-1,0},
{-2,1,0,0},
{1,1,1,1,0,1},
{1,-1,2,0},
{-1,0,0,-1,-1,-1,0,-1,-1,0},
{1,-1,-2,0},
{0,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1},
{-1,0,-1,0,1,0},
{-1,1,0,-1,0,-1,1,0},
{-1,0,1,1,0,0,0,0},
{1,1,0,1,1,0,0,1,1,0,1,1,1,1,1,0},
{-1,-1,0,1,0,1},
{0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0},
{0,-1,1,0,-1,-1,1,1},
{0,-1,1,-1,0,0,1,0,0,1,-1,0},
{0,-1,0,0,0,0,0,0,-1,1},
{0,0,0,1,1,-1,-1,-1},
{1,0,-1,0,0,0,0,-1,0,0,0,0,-1,0,0,1,0,-1,0,0},
{1,0,0,0,0,0,0,0,1,-1,0,0},
{-1,0,0,0,0,-1,0,1,0,-1,0,0,0,1,-1,0,1,0},
{0,1,-1,-2,2,1,-3,0,3,-1,-2,1},
{-1,-1,0,1,0,0,1,0},
{-1,2,-3,4,-5,6,-6,6,-6,5,-5,4,-3,2,-1,0},
{0,0,0,-1,1,1,-1,0,1,0,0,0,0,1,-1,0,1,0,-1,0},
{-1,1,0,1,0,1,0,1,-1,1,-1,0,-1,1,0,1},
{-1,0,0,0,0,0,0,-1,1,0,0,0,0,0,-1,1,0,0,0,0,0,-1,1,0},
{0,-1,-1,0,-1,0,1,0,1,0,0,0},
{1,0,0,0,1,0,0,-1,0,0,0,0,0,0,0,0,0,0},
{0,0,1,0,0,0,-1,0,0,-1,1,0,0,1,-1,0},
{0,0,-1,-1,0,0,0,0,-1,1,1,1},
{1,0,0,0,0,1,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1},
{-2,1,0,1,0,-2,3,-3,2,-4,2,1,-1,3,-5,3,-3,2,-1,-1,2,-1,2,-3},
{0,0,0,0,0,1,0,-1,0,0,1,0,0,-1,0,0},
{0,1,0,-1,1,1,-2,0,2,0,-2,1,1,-1,-1,1,0,-1,0,1},
{1,-1,0,0,0,0,-1,0,0,-1,1,0,0,0,0,1,0,0},
{-2,1,-1,0,0,0,1,0,1,-1,1,0,0,0,-1,1},
{1,0,-1,-1,0,1,1,0,-1,0,0,0,1,1,0,-1,-1,0,1,0},
{1,0,0,1,0,-1,0,-1,0,0,0,0,0,1,1,0,0,0,-1,0,0,-1,0,1},
{-1,1,0,-1,1,-1,0,0,-1,1,-1,0,1,-1,1,-1,0,1,-1,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,-1,0,0,0,0}};

int precomputed_U1[][max_d/2-1][max_d]={{},
{},
{},
{},
{{0,1,1,1}},
{},
{{0,1,0,0,0,1},
{1,0,0,1,1,0}},
{{0,1,1,1}},
{{1,0,1,0,0,0},
{0,0,1,-1,0,1}},
{{-1,0,0,1}},
{{0,1,0,0,0,0,0,0,0,1},
{1,0,0,0,0,0,1,0,0,0},
{0,1,0,1,0,1,0,0,0,0},
{0,1,0,0,0,1,0,0,0,0}},
{{-1,1,0,0}},
{{0,0,0,0,0,0,0,1,0,0,1,0},
{1,0,0,0,0,0,0,1,0,0,0,0},
{0,1,1,1,1,1,0,0,1,1,1,1},
{0,0,0,0,1,0,0,1,0,0,1,0},
{0,0,1,0,0,0,0,0,0,0,1,0}},
{{1,0,0,0,1,0},
{0,0,0,-1,1,0}},
{{1,-1,0,0,0,1,0,0},
{0,0,0,1,-1,0,1,0},
{0,1,1,-1,0,0,0,1}},
{{0,0,1,0,-1,0,1,0},
{0,0,-1,0,0,-1,0,1},
{0,0,0,1,1,1,0,0}},
{{0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0},
{0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0},
{0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1},
{0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0},
{0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0}},
{{0,-1,-1,0,1,0},
{1,0,-1,0,0,1}},
{{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1},
{1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1},
{1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0},
{1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0},
{1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0},
{0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1}},
{{-1,0,1,0,0,0,0,0},
{0,-1,1,0,0,0,0,0},
{0,0,0,0,-1,0,0,1}},
{{0,0,0,0,0,0,1,0,0,1,0,0},
{1,0,0,0,0,0,0,0,0,1,0,0},
{0,0,0,0,-1,1,0,-1,1,0,0,0},
{0,1,0,0,1,0,-1,0,0,0,1,1},
{-1,1,-1,0,0,0,-1,0,0,-1,1,0}},
{{0,0,0,1,0,1,0,0,0,0},
{-1,1,0,1,0,1,0,1,0,1},
{0,0,0,1,0,0,0,1,0,0},
{0,0,0,0,0,1,0,1,0,1}},
{{0,-1,0,0,0,1,0,1},
{0,0,0,0,0,0,-1,1},
{0,0,0,-1,0,0,-1,1}},
{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
{0,1,0,0,0,0,1,0,0,0,0,1,0,0,-1,0,1,0,0,0},
{0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0},
{0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},
{0,1,0,0,-1,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{1,0,0,0,0,1,0,0,0,-1,1,0,0,0,0,1,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0},
{0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0}},
{{-1,0,0,0,0,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,-1,0,0,1,0},
{0,0,0,0,0,0,0,1,-1,1,0,0},
{0,1,0,0,0,0,-1,0,0,0,0,1},
{0,0,-1,0,0,0,0,0,0,0,0,1}},
{{0,0,0,0,1,0,0,0,0,0,-1,0,0,1,0,0,0,0},
{0,-1,0,0,0,0,0,0,0,0,-1,0,0,1,0,0,0,0},
{1,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0},
{-1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0},
{0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0}},
{{-1,0,0,0,0,0,1,0,0,0,0,0},
{0,0,-1,0,1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,1,0,0,1,0},
{-1,0,1,1,0,0,1,1,0,0,1,1},
{0,-1,0,0,0,0,0,0,0,0,1,0}},
{{1,0,-1,0,0,0,0,1},
{0,0,-1,0,0,1,1,1},
{0,0,-1,-1,0,1,0,0}},
{{0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0},
{0,0,0,0,0,0,0,0,1,0,-1,0,1,0,0,0},
{0,0,0,0,-1,0,0,0,0,0,0,-1,0,1,0,0},
{0,1,-1,1,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,-1,0,0,0,0,1,0,0},
{0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0},
{0,0,1,0,0,-1,0,0,1,0,0,0,0,0,0,0}},
{{1,0,0,1,0,0,1,-1,0,0,-1,1,0,-1,1,0,0,1,0,0},
{0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
{-1,0,1,0,0,0,0,0,0,-1,0,0,0,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,1,0,0,0,-1,0,0,0,0,0,0,1,0},
{0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,1,0,0},
{1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0},
{0,-1,0,0,0,1,0,0,0,0,0,0,-1,0,0,0,1,0,0,0}},
{{0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0},
{1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,-1,0,0,0,0,0,0,0,0,1,0,0,0,0,0},
{0,1,0,0,-1,0,0,0,0,0,0,1,0,0,0,0},
{0,0,0,0,-1,1,-1,0,0,0,0,0,0,1,-1,1},
{0,0,0,1,-1,0,0,0,0,1,-1,0,0,0,0,1},
{0,0,-1,0,0,0,0,0,0,0,0,1,0,0,0,1}},
{{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
{-1,0,0,1,0,-1,0,-1,1,0,0,0,-1,1,-1,0,1,0,1,-1,0,-1,0,1},
{1,0,0,-1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,-1,0,0,1,0,0},
{0,0,0,1,0,-1,0,0,1,-1,0,0,0,1,-1,0,0,1,0,-1,0,0,1,0},
{0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,1,0},
{0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
{0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1},
{0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{-1,1,0,-1,1,-1,0,0,0,1,-1,1,0,0,0,0,1,-1,1,0,-1,1,0,0},
{0,0,0,0,0,-1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0}},
{{0,0,1,0,0,0,0,0,-1,0,0,1},
{0,0,0,0,-1,0,0,0,1,0,1,0},
{1,0,0,0,-1,0,0,0,0,0,1,0},
{0,0,-1,0,0,0,0,-1,1,0,0,0},
{0,0,0,0,0,0,-1,1,0,0,0,0}},
{{0,1,-1,1,0,0,-1,1,-1,0,0,1,-1,0,0,0,-1,1},
{0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0},
{0,-1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,1,0},
{0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0},
{0,0,-1,0,0,1,0,0,-1,0,0,1,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0}},
{{0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0},
{0,1,0,0,0,-1,0,-1,0,0,0,1,0,0,0,0},
{0,-1,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,-1,0,0,1,0},
{-1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,-1,0,0,0,0,0,0,1,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0}},
{{-1,0,0,0,0,0,0,0,0,1,0,0},
{1,0,0,0,-1,0,0,0,0,0,0,1},
{0,-1,0,0,0,0,0,0,1,0,1,0},
{0,0,0,1,1,0,0,0,0,0,0,0},
{0,-1,0,0,0,-1,0,0,1,0,0,0}},
{{0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0},
{1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0},
{0,0,0,0,-1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
{1,-1,-1,1,0,0,-1,1,0,0,-1,1,0,0,-1,1,0,0,-1,1},
{0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0}},
{{1,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,1,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,1,0,0,0,0,0,-1,0,0,1,0,0,0,0,0,0,0,0},
{0,0,-1,0,0,1,0,0,1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,1},
{0,0,0,-1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
{0,0,-1,0,0,0,0,0,1,0,0,-1,0,0,1,0,0,0,0,0,-1,0,1,1},
{0,-1,1,0,1,0,0,0,0,0,-1,0,0,1,0,0,-1,1,0,0,0,0,1,0},
{0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,1,0,0},
{0,1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,1,0,0},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0}},
{{-1,0,0,0,-1,0,0,0,1,0,0,0,1,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0},
{0,0,0,0,0,0,-1,0,0,0,0,0,-1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,-1,1,0,0,0,0},
{0,0,0,0,-1,0,0,0,0,0,0,0,1,1,0,0},
{1,0,0,0,0,0,0,0,-1,0,0,1,0,0,0,0},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},
{{-1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,-1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1,1,0},
{0,-1,0,0,0,1,1,0,0,0,0,-1,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0},
{0,-1,0,0,-1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1},
{0,-1,0,0,0,0,1,0,0,0,0,-1,0,0,-1,0,1,0,0,0},
{0,0,0,-1,0,0,0,0,1,0,-1,0,0,-1,0,0,0,0,1,0},
{0,0,-1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
{0,0,0,0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0,0,0}},
{{0,0,0,0,0,0,0,-1,0,0,0,0,0,1,0,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,1,0},
{0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,1,0},
{0,0,0,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,1},
{0,0,0,-1,-1,0,0,0,0,0,0,0,1,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,1},
{0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0}},
{{1,0,0,0,-1,0,0,0,0,0,0,0,0,0,1,0},
{-1,0,-1,0,0,0,1,0,0,0,0,0,0,0,0,0},
{1,0,0,0,0,0,-1,0,-1,0,0,0,1,0,0,0},
{0,1,0,0,0,-1,0,-1,0,0,0,0,0,1,1,1},
{0,0,-1,0,-1,-1,0,-1,0,0,0,0,1,1,0,1},
{1,1,0,0,-1,0,0,-1,-1,0,0,0,0,0,1,1},
{1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0}},
{{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
{0,0,-1,-1,0,0,0,0,-1,-1,0,0,1,1,0,0,0,0,1,1},
{0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,1,0,0,0,0},
{0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,0,0,0,0},
{1,0,-1,-1,0,1,1,0,-1,-1,-1,0,1,1,0,-1,-2,0,1,1},
{0,0,-1,-1,0,1,1,0,-1,-1,0,1,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,1,0,0},
{0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0},
{0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},
{{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
{0,0,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
{1,0,0,1,0,0,0,-1,-1,0,0,0,0,1,1,0,0,1,-1,0,0,-1,0,1},
{0,-1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,-1,0,0,0,0,0,0,1,0,0,0,0,0,0,-1,0,-1,0,0,0,0,1},
{0,-1,1,0,0,0,0,0,1,0,0,0,0,0,0,-1,0,0,0,0,0,0,1,0},
{-1,0,0,0,0,0,-1,1,0,0,0,0,0,0,-1,0,0,0,0,0,0,1,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,0},
{0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},
{{0,0,0,-1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
{1,0,0,0,0,0,-1,0,0,0,1,0,0,0,-1,0,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0},
{1,0,0,0,-1,0,-1,0,-1,0,1,0,1,0,-1,0,-1,0,0,0,1,0,2,0},
{0,0,0,-1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
{0,1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
{0,0,0,0,0,-1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
{1,0,0,1,-1,0,-1,0,0,0,1,0,1,0,-1,0,-1,-1,0,0,1,0,1,0},
{1,-1,0,0,-1,0,-1,0,0,0,1,0,1,0,-1,0,-1,0,0,0,1,0,1,0},
{1,0,1,0,0,0,-1,1,-1,0,1,0,1,0,0,0,-1,0,-1,0,0,0,1,0},
{1,0,0,0,-1,0,-1,1,0,0,1,0,1,0,-1,0,-1,0,0,0,1,0,1,0}},
{{0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
{0,0,0,0,0,0,0,-1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
{1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,0,0,1,1,0,0,1,1,0},
{0,0,1,0,0,0,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,0,1,0,0,1},
{0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0},
{0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0},
{0,0,0,0,0,-1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0}}};

int precomputed_U2[][max_d/2-1][max_d]={{},
{},
{},
{},
{{-1,-1,0,-1}},
{},
{{0,0,0,-1,-1,-1},
{1,0,1,1,1,1}},
{{0,-1,1,-1}},
{{1,-1,-1,1,0,-1},
{0,0,1,1,1,1}},
{{-1,1,-1,0}},
{{-1,-1,0,0,0,-1,-1,-1,0,0},
{1,1,1,1,1,1,0,0,0,0},
{0,-1,-1,-1,-1,0,0,-1,-1,-1},
{-1,0,-1,-1,0,-1,0,0,-1,0}},
{{0,0,-1,-1}},
{{-1,-1,-1,0,0,0,0,-1,-1,-1,0,0},
{1,1,1,1,1,1,1,0,0,0,0,0},
{-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1},
{0,1,1,1,0,1,1,1,0,1,1,1},
{1,1,0,1,1,0,0,1,0,0,1,1}},
{{1,-1,1,-1,0,0},
{-1,0,-1,0,0,1}},
{{-1,0,0,-1,1,-1,-1,1},
{-1,1,0,-1,0,-1,0,1},
{1,-1,0,0,-1,0,0,-1}},
{{0,0,-1,0,-1,0,-1,0},
{-1,0,0,0,1,-1,1,-1},
{0,-1,1,0,-1,0,1,-1}},
{{-1,-1,-1,0,0,0,-1,-1,0,0,0,-1,-1,-1,0,0},
{1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0},
{0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0},
{0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
{-1,-1,0,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0},
{1,0,0,1,0,1,1,0,1,1,0,1,1,0,1,0},
{-1,0,-1,-1,0,-1,0,-1,0,0,-1,0,-1,0,0,-1}},
{{-1,0,0,0,1,-1},
{1,0,0,-1,-1,-1}},
{{0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0},
{0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1},
{1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0},
{0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0},
{1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
{1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1},
{0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1}},
{{0,0,-1,0,0,0,-1,0},
{0,-1,-1,0,0,-1,-1,0},
{0,0,-1,0,1,-1,0,1}},
{{0,0,0,-1,1,0,0,0,0,-1,0,1},
{0,0,0,-1,0,0,-1,0,0,-1,0,0},
{-1,1,0,-1,1,1,-1,0,1,-1,0,2},
{-1,1,-1,-1,1,0,-1,0,1,-1,0,1},
{1,0,-1,1,0,-1,1,1,-1,0,1,0}},
{{0,1,-1,0,0,1,-1,0,-1,1},
{0,-1,1,-1,1,-1,1,-1,1,-1},
{1,-1,0,-1,0,0,1,0,0,-1},
{0,1,-1,0,0,0,-1,1,0,0}},
{{0,1,0,-1,0,-1,0,1},
{-1,-1,-1,-1,0,0,1,1},
{-1,0,1,0,0,-1,0,1}},
{{1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
{0,-1,0,0,-1,1,-1,0,1,-1,1,-1,-1,1,-1,0,0,-1,1,0},
{0,-1,0,0,1,0,-1,-1,0,1,1,-1,-1,-1,1,1,0,0,-1,0},
{1,1,1,1,0,1,1,1,1,0,1,1,0,0,-1,0,0,0,0,-1},
{0,1,-1,1,-1,0,1,-1,1,-1,1,0,0,1,-1,1,0,0,0,0},
{-1,1,0,-1,0,0,0,-1,0,1,-1,0,0,0,0,0,1,-1,-1,1},
{1,-1,0,1,-1,0,0,-1,0,0,0,-1,0,0,-1,1,-1,-1,1,0},
{0,0,0,1,-1,0,1,-1,1,0,0,1,-1,1,0,-1,1,0,0,0},
{-1,0,1,1,1,-1,-1,0,0,1,0,0,1,0,0,-1,-1,1,1,1}},
{{-1,1,0,0,-1,0,0,1,-1,0,-1,1},
{-1,1,-1,0,0,0,0,1,-1,1,0,0},
{1,0,0,-1,0,0,0,-1,0,0,1,0},
{0,0,0,0,1,0,1,0,1,0,1,0},
{-1,0,-1,1,0,1,0,0,-1,0,-1,1}},
{{0,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1},
{0,0,0,0,0,-1,0,0,0,0,0,1,0,0,0,0,0,-1},
{1,0,-1,1,0,-1,0,1,-1,0,1,-1,0,1,0,-1,1,0},
{0,0,-1,1,-1,0,0,-1,1,-1,1,-1,1,0,-1,1,-1,1},
{0,1,-1,-1,1,1,-1,-1,1,1,0,-1,0,1,0,-1,0,1},
{-1,0,1,-1,1,0,-1,1,-1,-1,1,0,0,1,-1,0,1,-1},
{1,-1,1,-1,1,-1,0,0,0,1,-1,1,-1,1,-1,1,-1,1},
{1,0,-1,-1,0,1,0,-1,-1,1,1,0,-1,-1,1,1,0,-1}},
{{0,0,-1,0,1,0,-1,0,0,0,0,0},
{-1,0,0,0,-1,0,0,0,-1,0,0,0},
{0,1,0,-1,-1,1,1,-1,-1,0,1,0},
{-1,1,0,-1,0,1,0,-1,0,1,0,-1},
{0,0,1,1,-1,-1,0,0,-1,0,1,1}},
{{0,0,1,0,0,0,-1,-1},
{-1,-1,1,1,1,0,-1,-1},
{1,0,-1,-1,0,-1,1,1}},
{{0,0,-1,0,0,0,1,0,0,0,-1,0,0,0,0,0},
{-1,0,-1,0,0,0,1,0,0,0,-1,0,-1,0,0,0},
{-1,-1,-1,-1,0,1,1,1,1,0,0,-1,-1,-1,0,0},
{0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,-1},
{1,1,1,1,1,1,1,1,1,0,0,0,0,0,-1,-1},
{0,0,0,-1,1,-1,1,-1,1,-1,1,-1,1,-1,0,0},
{-1,0,1,0,-1,0,1,-1,-1,1,0,-1,0,1,-1,-1}},
{{1,-1,0,1,-1,0,1,-1,0,1,-1,0,0,-1,1,0,-1,1,0,-1},
{0,1,0,-1,0,0,0,0,0,0,1,0,0,0,-1,0,1,0,0,1},
{0,0,1,-1,0,0,0,0,1,-1,0,0,0,1,0,0,0,0,0,1},
{0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1},
{0,1,1,-1,0,0,-1,0,1,0,1,0,0,1,-1,-1,1,0,0,1},
{1,0,0,1,0,0,0,-1,-1,0,-1,0,1,0,1,1,0,0,0,-1},
{0,0,0,0,0,0,0,1,-1,0,1,-1,0,1,-1,0,1,0,0,0},
{0,-1,0,1,0,0,0,-1,0,0,0,1,-1,-1,1,0,0,1,0,-1},
{-1,1,0,-1,0,1,-1,0,0,0,1,-1,0,1,0,-1,1,0,0,0}},
{{0,0,0,-1,1,-1,1,-1,0,0,0,0,1,-1,1,-1},
{0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0},
{0,0,0,0,0,0,0,0,-1,1,-1,1,-1,1,-1,1},
{0,-1,1,-1,0,-1,1,-1,0,-1,1,-1,0,0,1,-1},
{1,-1,0,-1,1,-1,1,-1,1,-1,1,-1,1,0,1,-1},
{0,0,-1,0,0,0,-1,1,0,0,-1,1,0,0,-1,1},
{0,1,0,1,0,0,-1,0,-1,0,0,0,0,1,0,1}},
{{-1,0,0,0,1,-1,0,-1,0,1,-1,1,-1,1,0,-1,1,-1,1,0,0,0,-1,1},
{-1,1,0,0,1,-1,1,-1,1,1,-1,1,-1,1,-1,0,1,-1,1,0,0,0,0,1},
{-1,0,0,0,1,-1,0,-1,0,1,-1,1,-1,0,0,-1,1,-1,1,0,-1,0,0,1},
{1,0,0,-1,0,1,0,1,-1,0,0,0,1,0,1,0,0,0,-1,1,0,1,0,-1},
{0,1,0,0,-1,-1,1,0,1,0,0,0,-1,0,0,1,1,0,0,-1,0,0,0,1},
{2,1,-1,-1,-1,1,0,1,0,-1,1,0,1,0,0,1,-1,0,-1,0,1,1,1,-1},
{-1,0,0,0,1,-1,0,0,0,0,0,1,-1,1,0,-1,0,0,1,-1,0,0,-1,1},
{0,-1,1,0,0,0,-1,1,-1,0,1,-1,1,0,0,0,-1,1,0,0,0,0,0,0},
{1,0,0,0,-1,1,-1,1,0,0,1,-1,1,-1,1,0,0,0,-1,1,0,1,0,0},
{-1,1,0,1,0,-1,0,-1,2,0,0,0,-1,1,-1,1,0,0,1,-1,0,-1,1,1},
{0,0,0,0,0,0,1,-1,0,0,0,1,0,0,-1,0,1,0,1,-1,0,0,0,1}},
{{0,1,0,0,1,0,0,-1,0,0,-1,0},
{0,0,-1,0,1,0,-1,0,1,0,-1,0},
{1,0,0,0,0,0,-1,0,-1,0,-1,0},
{0,1,1,0,-1,-1,-1,-1,0,1,1,1},
{-1,-1,-1,-1,-1,-1,0,0,0,0,0,0}},
{{1,-1,1,-1,1,-1,1,-1,1,-1,1,0,1,-1,1,-1,1,-1},
{1,0,1,0,0,0,0,-1,0,-1,0,0,0,0,1,0,1,0},
{0,-1,1,0,0,-1,0,0,1,-1,0,0,1,-1,0,0,1,-1},
{0,0,0,0,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1},
{0,0,0,0,-1,1,-1,1,0,0,0,0,0,1,-1,1,-1,1},
{-1,0,0,1,0,1,-1,0,-1,0,0,1,0,0,-1,0,-1,1},
{0,0,0,1,0,0,0,0,-1,0,-1,0,0,0,0,1,0,1},
{-1,0,-1,1,0,1,0,1,0,0,-1,0,-1,0,-1,0,0,1}},
{{0,0,1,0,0,0,-1,0,0,0,0,0,0,0,0,0},
{0,-1,0,0,0,1,0,0,0,-1,0,1,0,1,0,0},
{0,0,0,-1,0,-1,0,0,0,0,0,-1,0,-1,0,0},
{0,-1,0,0,-1,1,0,-1,1,0,-1,1,0,0,1,0},
{0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1},
{-1,1,-1,0,1,-1,1,-1,0,0,-1,1,0,0,0,0},
{1,1,-1,-1,0,0,0,0,0,1,0,-1,-1,0,1,0}},
{{0,0,0,-1,0,0,1,0,0,-1,0,0},
{1,1,0,-1,0,0,0,0,-1,-1,0,0},
{1,1,-1,-1,0,0,0,0,-1,0,1,0},
{-2,0,0,2,1,-1,-1,1,1,1,-1,-2},
{-1,0,0,0,1,-1,-1,1,0,1,0,-1}},
{{0,1,0,0,0,0,0,-1,0,0,0,-1,0,1,0,0,0,1,0,-1},
{1,0,-1,0,0,0,0,0,1,0,-1,0,0,0,0,0,1,0,-1,0},
{0,0,0,0,0,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0},
{0,0,-1,0,1,0,-1,0,0,0,0,0,0,0,-1,0,1,0,0,0},
{0,0,-1,-1,0,0,-1,-1,1,1,0,0,1,1,0,-1,0,0,-1,-1},
{0,1,0,-1,0,1,-1,-1,1,1,-1,-1,1,0,-1,0,1,0,0,0},
{-1,0,1,-1,0,1,0,0,-1,0,1,-1,0,0,0,0,-1,1,1,-1},
{-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1},
{0,0,1,0,-1,-1,1,1,0,-1,0,0,-1,0,1,1,-1,-1,0,1}},
{{1,0,0,0,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1,0,0,-1,0,0},
{1,0,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,1,0,0,-1,0,0},
{0,0,0,0,-1,0,0,1,0,0,-1,0,0,0,0,0,1,0,0,-1,0,0,1,0},
{0,0,0,0,0,0,0,-1,-1,0,1,1,1,0,0,0,-1,-1,-1,0,1,1,0,0},
{0,-1,1,1,0,-1,-1,0,1,0,-1,0,0,1,0,-1,-1,1,1,0,0,-1,0,0},
{2,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,-1,-1},
{0,-1,0,1,0,-1,0,1,0,-1,0,0,0,0,0,0,-1,1,0,-1,0,1,1,-1},
{0,-1,2,-1,0,0,0,0,0,0,-1,1,-1,1,-1,0,0,1,-1,0,1,-1,1,-1},
{0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0},
{-1,0,1,1,0,0,0,0,-1,0,0,1,1,0,0,-1,0,0,0,0,1,1,0,-1},
{0,0,0,-1,0,0,0,1,0,1,-1,0,-1,0,1,0,1,-1,0,-1,0,0,0,1}},
{{1,0,0,0,-1,0,0,0,-1,0,0,0,1,0,0,0},
{1,0,-1,0,1,0,-1,0,0,0,0,0,-1,0,1,0},
{-1,0,0,0,1,0,0,0,0,0,-1,0,0,0,1,0},
{-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,1,1},
{1,0,-1,1,-1,0,1,-1,-1,1,0,-1,1,-1,0,1},
{-1,1,0,0,1,-1,1,0,1,0,-1,1,-1,0,0,-1},
{0,1,0,-1,0,1,0,-1,-1,0,1,0,-1,-1,1,1}},
{{0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0},
{-1,1,-1,0,1,0,0,0,-1,0,-1,1,0,0,1,0,-1,1,-1,0},
{1,1,0,-1,-1,0,0,-1,0,1,1,0,0,-1,0,0,-1,-1,1,1},
{-1,-1,0,0,0,1,1,1,1,1,-1,-1,-1,-1,-1,0,0,0,0,1},
{0,0,0,0,0,0,-1,0,1,0,-1,1,1,-1,-1,1,0,-1,0,1},
{0,1,0,0,-1,-1,-1,0,1,1,1,1,-1,-1,-1,0,0,1,1,0},
{0,0,0,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,0,0,0,0,0},
{1,-1,-1,-1,1,0,1,0,0,-1,1,0,-1,-1,0,0,1,1,0,-1},
{-1,-1,-1,-1,-1,0,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,1}},
{{0,0,-1,0,0,1,0,0,-1,0,0,1,0,0,-1,0,0,0},
{0,0,-1,0,0,-1,0,0,-1,0,0,0,0,0,1,0,0,1},
{0,0,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,0,0},
{0,1,0,-1,-1,0,1,0,-1,-1,-1,1,1,0,-1,-1,1,1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,1,1,1,1,1,1,1},
{1,-1,0,1,-1,0,0,-1,1,-1,0,1,-1,0,1,-1,1,0},
{1,-1,1,-1,0,0,-1,1,-1,0,0,-1,1,-1,1,0,0,1},
{1,1,-1,-1,1,1,0,-1,0,0,-1,0,1,0,-1,-1,1,1}},
{{0,0,0,0,1,0,0,0,0,0,0,0,-1,0,-1,0},
{0,0,-1,0,0,0,0,0,0,0,0,0,1,0,-1,0},
{0,0,-1,0,-1,0,0,0,0,0,1,0,1,0,1,0},
{1,-1,1,0,0,0,0,0,-1,0,-1,0,0,0,1,0},
{-1,1,0,1,0,0,0,-1,0,-1,1,-1,0,0,0,1},
{1,-1,0,0,-1,0,-1,1,-1,0,0,0,0,-1,1,-1},
{0,0,0,0,0,0,1,-1,1,-1,1,-1,0,0,0,0}},
{{0,0,0,-1,0,0,1,0,0,-1,0,0,1,0,0,-1,0,0,0,0},
{-1,0,0,1,0,-1,-1,0,1,1,0,0,-1,0,0,1,1,0,-1,-1},
{-1,0,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,1,0,-1,-1},
{0,0,-1,-1,0,1,0,0,0,0,0,0,0,1,0,-1,-1,0,0,0},
{-2,-1,1,1,1,-1,-1,-1,1,1,1,1,-1,-1,-1,1,1,1,0,-2},
{1,0,-1,-1,0,1,1,0,-1,-1,0,-1,1,1,0,-1,-1,0,1,1},
{-1,-1,-1,0,0,0,-1,-1,-1,0,0,1,0,0,-1,0,0,1,1,0},
{0,0,0,-1,-1,0,0,1,1,0,0,0,0,1,1,0,-1,-1,-1,0},
{0,-1,-1,1,1,0,0,0,-1,0,1,0,0,0,-1,-1,0,1,0,0}},
{{-1,0,0,0,0,0,0,1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0},
{0,-1,0,0,0,0,0,0,1,0,0,0,0,0,-1,-1,0,0,0,0,0,0,1,0},
{-1,0,0,0,1,1,0,0,0,-1,-1,-1,0,0,0,1,1,1,1,0,-1,0,-1,-1},
{-1,-1,0,0,1,1,1,1,1,0,-1,-2,-2,-1,0,1,1,1,1,1,0,-1,-1,-1},
{1,0,1,0,0,-1,-1,-2,-1,-1,0,0,1,1,1,0,0,-1,-1,-1,-1,-1,0,0},
{-2,-1,1,-1,1,1,0,2,1,-1,-1,-1,-1,-1,-1,0,2,1,1,1,-1,1,0,-2},
{0,0,1,1,0,0,-1,-1,-1,-1,0,1,1,1,0,0,0,-1,-1,0,0,0,0,0},
{0,-1,0,1,0,0,1,0,0,0,0,-1,-1,0,0,-1,0,1,0,0,1,0,0,0},
{0,0,-1,-1,0,0,-1,0,1,1,0,0,0,0,-1,-1,-1,0,1,0,0,1,1,0},
{-3,-1,1,-1,1,3,1,2,2,-2,-2,-2,-2,-2,-1,1,3,1,3,1,-1,0,0,-4},
{3,0,0,1,-1,-2,-1,-2,-1,1,1,2,1,1,2,-2,-1,-1,-2,-1,1,-1,1,2}},
{{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1,0,0,0,0,0,1},
{0,0,1,0,1,0,0,0,-1,0,0,0,0,0,1,0,0,0,-1,0,-1,0,0,0},
{0,1,0,0,0,0,0,-1,0,0,0,0,0,1,0,-1,0,0,0,-1,0,1,0,0},
{1,0,1,0,-1,0,-2,0,0,0,1,0,1,0,0,0,-2,0,-1,0,1,0,1,0},
{0,0,0,0,0,-1,0,0,0,1,0,0,0,-1,0,-1,0,0,0,1,0,0,0,-1},
{0,-1,0,0,0,1,0,1,0,0,0,-1,0,-1,0,1,0,1,0,0,-1,-1,0,-1},
{0,-1,0,0,0,0,0,1,0,0,-1,0,0,-1,0,0,1,0,0,0,0,0,-1,0},
{1,-2,-1,-1,1,2,0,1,0,2,1,-1,-1,-2,0,2,0,1,-1,1,1,-1,-1,-3},
{0,1,0,1,-1,0,-1,0,0,-1,1,-1,2,-1,1,-1,-1,0,-1,1,-1,1,0,1},
{-1,-3,-1,0,1,0,0,3,2,1,-1,-1,0,-2,-1,1,2,2,0,1,1,-1,-2,-3},
{-1,-1,-1,0,1,2,2,1,0,-2,-2,-1,-1,1,2,2,1,0,-1,-2,-1,-1,0,1}},
{{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,-1,0,0,-1,0,0,0},
{0,0,1,0,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,0,1},
{0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0},
{0,-1,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,-1,0,0,-1,0},
{-1,0,1,-1,1,1,-1,0,0,0,0,0,0,-1,0,1,-1,0,1,-1,0,0,0,1},
{1,0,0,1,-1,0,0,0,0,-1,1,-1,-1,1,-1,0,0,0,0,0,1,0,0,0},
{0,0,-2,2,-2,1,-1,0,1,-1,1,0,0,0,1,-1,1,0,-1,1,-2,2,-2,0},
{-1,0,0,-1,0,1,0,-1,1,2,-1,-1,2,1,-2,0,2,0,-2,0,1,-1,-1,0},
{1,-1,1,0,0,0,0,0,0,-1,0,-1,-1,0,-1,-1,0,-1,0,-1,0,0,-1,0},
{-1,1,0,-2,2,0,-2,2,0,-1,1,-1,1,0,-1,2,-1,-1,2,-1,-1,1,0,-1}}};


lli getrandom(lli gen)  {
    
    gen=(PRIMITIVE_ROOT*gen)%BIG_PRIME;
    if(gen<0)gen+=BIG_PRIME;
    if(gen==0)gen=1;
    
    return gen;
}

long double mpf_to_longdouble(mpf_t t)  {
// convert float from gmp to long double type (in gmp we can do qucikly the conversion only to double)
// assume that t fits in long double
    
    int sg;
    if(mpf_sgn(t)==0)return 0;// t=0
    else if(mpf_sgn(t)<0)  {mpf_neg(t,t);sg=1;}// t<0
    else sg=0;// t>0
    
    char w[precision_in_bits+1024];
    mp_exp_t exponent[32];
    
    mpf_get_str(w,exponent,2,precision_in_bits,t);
    
    int i,len=strlen(w),sh=exponent[0]-1;
    long double x=0,p=1;

    while(sh>0){p*=2L;sh--;}
    while(sh<0){p/=2L;sh++;}

    for(i=0;i<len;i++){
        if(w[i]=='1')x+=p;
        p/=2L;
    }
    
    if(sg){x=-x;mpf_neg(t,t);}
    
    return x;
}

void longlongtompz(mpz_ptr x,lli n)  {
    int hi,lo,sg;
    
    if(n<0){sg=1;n=-n;}
    else sg=0;
    lo=n&0x7fffffff;
    n>>=31;
    hi=n;
    
    mpz_set_ui(x,hi);
    mpz_mul_2exp(x,x,31);
    mpz_add_ui(x,x,lo);
    
    if(sg)mpz_neg(x,x);
    return;
}

lli mpztolonglong(mpz_t x)  {
    
    mpz_t temp;
    mpz_init(temp);
    lli ret;
    int sg;
    if(mpz_sgn(x)<0){mpz_neg(x,x);sg=1;}
    else sg=0;
    
    mpz_fdiv_q_2exp(temp,x,31);
    ret=mpz_get_ui(temp);
    ret<<=31;
    mpz_fdiv_r_2exp(temp,x,31);
    ret+=mpz_get_ui(temp);
    mpz_clear(temp);
    
    if(sg){mpz_neg(x,x);ret=-ret;}
    
    return ret;
}

void inits(void)  {
    
    int h,i,j;
    mpf_set_default_prec(precision_in_bits);
    mpf_init_set_ui(smalleps,1);
    mpf_div_2exp(smalleps,smalleps,precision_in_bits);

    for(i=0;i<max_d/2-1;i++)for(j=0;j<max_d;j++)mpz_init(U1[i][j]);
    for(i=0;i<max_d/2-1;i++)for(j=0;j<max_d;j++)mpz_init(U2[i][j]);
    for(h=0;h<=max_exponent;h++)for(i=0;i<max_d/2-1;i++)for(j=0;j<max_d;j++)mpz_init(U1pow[i][h][j]);
    for(h=0;h<=max_exponent;h++)for(i=0;i<max_d/2-1;i++)for(j=0;j<max_d;j++)mpz_init(U2pow[i][h][j]);
    for(i=0;i<max_d;i++)mpz_init(S[i]);
    for(i=0;i<max_d;i++)for(j=0;j<max_d;j++)mpz_init(SS[i][j]);
    for(i=0;i<max_d;i++)for(j=0;j<max_d;j++)mpz_init(SS2[i][j]);
    for(i=0;i<max_e;i++)for(j=0;j<2;j++)mpf_init(R_array[i][j]);

    return;
}

void del(void)  {
    
    int h,i,j;
    mpf_set_default_prec(precision_in_bits);
    mpf_clear(smalleps);

    for(i=0;i<max_d/2-1;i++)for(j=0;j<max_d;j++)mpz_clear(U1[i][j]);
    for(i=0;i<max_d/2-1;i++)for(j=0;j<max_d;j++)mpz_clear(U2[i][j]);
    for(h=0;h<=max_exponent;h++)for(i=0;i<max_d/2-1;i++)for(j=0;j<max_d;j++)mpz_clear(U1pow[i][h][j]);
    for(h=0;h<=max_exponent;h++)for(i=0;i<max_d/2-1;i++)for(j=0;j<max_d;j++)mpz_clear(U2pow[i][h][j]);
    for(i=0;i<max_d;i++)mpz_clear(S[i]);
    for(i=0;i<max_d;i++)for(j=0;j<max_d;j++)mpz_clear(SS[i][j]);
    for(i=0;i<max_d;i++)for(j=0;j<max_d;j++)mpz_clear(SS2[i][j]);
    for(i=0;i<max_e;i++)for(j=0;j<2;j++)mpf_clear(R_array[i][j]);

    return;
}

void init_tables(int d,int e)  {
    
    int h,i,j,pos;
    mpz_t v[d];
    for(i=0;i<d;i++)mpz_init(v[i]);
    length_U1=d/2-1;
    len_SS=d;

    pos=0;
    while(allowed[pos]!=e)pos++;
    
    for(i=0;i<=d;i++)polcyclo[i]=precomputed_polcyclo[pos][i];
    for(i=0;i<d/2-1;i++)for(j=0;j<d;j++)mpz_set_si(U1[i][j],precomputed_U1[pos][i][j]);
    for(i=0;i<d/2-1;i++)for(j=0;j<d;j++)mpz_set_si(U2[i][j],precomputed_U2[pos][i][j]);
    for(i=0;i<d;i++)mpz_set_si(S[i],precomputed_S[pos][i]);

    NS=precomputed_NS[pos];
    setup_l(e);
    setup_R(e);
    setup_SS2(d,e);
    setup_MM(d,e);
    
    for(i=0;i<e;i++)for(j=0;j<d;j++)i_mul_l_array[i][j]=(i*l_array[j])%e;

    for(i=0;i<d/2-1;i++)  {
        for(j=0;j<d;j++)mpz_set_ui(v[j],j==0);
        for(h=0;h<=max_exponent;h++)  {
            set_arrays_z(U1pow[i][h],v,d);
            mul_z(v,v,U1[i],d,e);
        }

        for(j=0;j<d;j++)mpz_set_ui(v[j],j==0);
        for(h=0;h<=max_exponent;h++)  {
            set_arrays_z(U2pow[i][h],v,d);
            mul_z(v,v,U2[i],d,e);
        }
    }    
    
    for(i=0;i<d;i++)mpz_clear(v[i]);
    c_init_tables(d,e);

    return;
}    

void c_init_tables(int d,int e)  {
    
    int h,i,j,pos;
    
    pos=0;
    while(allowed[pos]!=e)pos++;

    for(i=0;i<d;i++)
        for(j=0;j<d;j++)  {
            c_SS[i][j]=mpztolonglong(SS[i][j]);
            c_SS2[i][j]=mpztolonglong(SS2[i][j]);
            assert(mpz_sizeinbase(SS[i][j],2)<=62);
            assert(mpz_sizeinbase(SS2[i][j],2)<=62);
        }
    
    for(i=0;i<d/2-1;i++)for(j=0;j<d;j++)c_U1[i][j]=precomputed_U1[pos][i][j];
    for(i=0;i<d/2-1;i++)for(j=0;j<d;j++)c_U2[i][j]=precomputed_U2[pos][i][j];
    for(i=0;i<d;i++)c_S[i]=precomputed_S[pos][i];    
    
    for(i=0;i<d/2-1;i++)
        for(h=0;h<=max_exponent;h++)
            for(j=0;j<d;j++)  {
                c_U1pow[i][h][j]=mpztolonglong(U1pow[i][h][j]);
                c_U2pow[i][h][j]=mpztolonglong(U2pow[i][h][j]);
                assert(mpz_sizeinbase(U1pow[i][h][j],2)<=62);
                assert(mpz_sizeinbase(U2pow[i][h][j],2)<=62);
            }
   
   for(i=0;i<e;i++)  {
       c_R_array[i][0]=mpf_to_longdouble(R_array[i][0]);
       c_R_array[i][1]=mpf_to_longdouble(R_array[i][1]);
   }
   
   return;
}

void setup_l(int e)  {
    
    int i,ct=0;
    
    for(i=1;i<=e;i++)
        if(iigcd(i,e)==1)  l_array[ct++]=i;
    
    assert(ct==eulerphi(e));
    return;
}

void setup_R(int e)  {

    int j;
    mpf_t re,re2,im,im2,temp,co,si;
    mpf_init(re2);
    mpf_init(im2);
    mpf_init(temp);
    mpf_init(co);
    mpf_init(si);
    
    mpf_set_str(temp,PI,10);
    mpf_mul_ui(temp,temp,2);
    mpf_div_ui(temp,temp,e);

    sin_f(si,temp);
    cos_f(co,temp);
    
    mpf_init_set_ui(re,1);
    mpf_init_set_ui(im,0);
    
    for(j=0;j<e;j++)  {
        mpf_set(R_array[j][0],re);
        mpf_set(R_array[j][1],im);
        mpf_set(re2,re);
        mpf_set(im2,im);
        
        mpf_mul(re,re2,co);
        mpf_mul(temp,im2,si);
        mpf_sub(re,re,temp);
        
        mpf_mul(im,re2,si);
        mpf_mul(temp,im2,co);
        mpf_add(im,im,temp);
    }
    
    mpf_clear(re);
    mpf_clear(re2);
    mpf_clear(im);
    mpf_clear(im2);
    mpf_clear(temp);
    mpf_clear(co);
    mpf_clear(si);
    return;
}

void setup_MM(int d,int e)  {
    
    int i,j,k;
    double dd,M[d/2][d/2],TR[d/2][d/2],inv[d/2][d/2];
    mpf_t t,temp,ex[d/2][2];
    mpf_init(t);
    mpf_init(temp);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_init(ex[i][j]);
    
    for(i=0;i<length_U1;i++)  {
        embed_z(ex,U1[i],d,e);
        for(j=0;j<d/2;j++)  {
            abs_complex_f(t,ex[j][0],ex[j][1]);
            M[i][j]=log_f(t);
        }
    }

    for(i=0;i<d/2-1;i++)
        for(j=0;j<d/2-1;j++)  {
            dd=0.0;
            for(k=0;k<d/2;k++)dd+=M[i][k]*M[j][k];
            TR[i][j]=dd;
        }
    
    for(i=0;i<d/2-1;i++)
        for(j=0;j<d/2-1;j++)  inv[i][j]=(i==j);
    
    for(i=0;i<d/2-1;i++)  {
        dd=TR[i][i];
        for(j=0;j<d/2-1;j++)  TR[i][j]/=dd;
        for(j=0;j<d/2-1;j++)  inv[i][j]/=dd;
        for(j=i+1;j<d/2-1;j++){
            dd=TR[j][i];
            for(k=0;k<d/2-1;k++)TR[j][k]-=dd*TR[i][k];
            for(k=0;k<d/2-1;k++)inv[j][k]-=dd*inv[i][k];
        }
    }
    for(i=d/2-2;i>=0;i--)
        for(j=i-1;j>=0;j--)  {
            dd=TR[j][i];
            for(k=j;k<=i;k++)TR[j][k]-=dd*TR[i][k];
            for(k=0;k<d/2-1;k++)inv[j][k]-=dd*inv[i][k];
        }

    for(i=0;i<d/2-1;i++)
        for(j=0;j<d/2;j++)  {
            dd=0.0;
            for(k=0;k<d/2-1;k++)dd+=inv[i][k]*M[k][j];
            MM[i][j]=dd;
        }
    mpf_clear(t);
    mpf_clear(temp);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_clear(ex[i][j]);

    return;
}

void sin_f(mpf_ptr ans,mpf_t x)  {
// ans=sin(x) with small error
    
    mpf_t x2,temp;
    mpf_init(x2);
    mpf_init_set(temp,x);
    
    mpf_set_ui(ans,0);
    mpf_pow_ui(x2,x,2);
    mpf_neg(x2,x2);
    
    unsigned long int i=2;
    while(mpf_sgn(temp)<0||mpf_cmp(temp,smalleps)>0)  {
          mpf_add(ans,ans,temp);
          mpf_mul(temp,temp,x2);
          mpf_div_ui(temp,temp,i);
          mpf_div_ui(temp,temp,i+1);
          i+=2;
    }    
    
    mpf_clear(x2);
    mpf_clear(temp);
    return;
}    

void cos_f(mpf_ptr ans,mpf_t x)  {
// ans=cos(x) with small error
    
    mpf_t x2,temp;
    mpf_init(x2);
    mpf_init_set_ui(temp,1);
    
    mpf_set_ui(ans,0);
    mpf_pow_ui(x2,x,2);
    mpf_neg(x2,x2);
    
    unsigned long int i=1;
    while(mpf_sgn(temp)<0||mpf_cmp(temp,smalleps)>0)  {
          mpf_add(ans,ans,temp);
          mpf_mul(temp,temp,x2);
          mpf_div_ui(temp,temp,i);
          mpf_div_ui(temp,temp,i+1);
          i+=2;
    }
    
    mpf_clear(x2);
    mpf_clear(temp);
    return;
}    

void conjugate(mpz_t y[],mpz_t x[],int i,int d,int e)  {
// assume that length of x and y is d
    int j;
    mpz_t z[e];
    
    for(j=0;j<e;j++)mpz_init_set_ui(z[j],0);
    for(j=0;j<d;j++)mpz_set(z[(i*j)%e],x[j]);
    
    bigreduce_z(z,d,e);
    for(j=0;j<d;j++)mpz_set(y[j],z[j]);
    for(j=0;j<e;j++)mpz_clear(z[j]);
    
    return;
}

void setup_SS(int d,int e)  {
    
    int i;
    for(i=0;i<d;i++)
        conjugate(SS[i],S,l_array[i],d,e);
    return;
}

void setup_SS2(int d,int e)  {
    
    int i,j,k;
    mpz_t y[d],t[d];
    for(i=0;i<d;i++){mpz_init(y[i]);mpz_init(t[i]);}

    setup_SS(d,e);
    for(i=0;i<d;i++)  {
        for(k=0;k<d;k++)mpz_set_ui(y[k],(k==0));
        for(j=0;j<d;j++)
            if(l_array[j]!=1){
               conjugate(t,SS[i],l_array[j],d,e);
               mul_z(y,y,t,d,e);
            }
        for(k=0;k<d;k++)mpz_set(SS2[i][k],y[k]);
    }
    
    for(i=0;i<d;i++){mpz_clear(y[i]);mpz_clear(t[i]);}
    return;
}

void reduce_f(mpf_t x[],int d,int e)  {
     int i,j;
     
     for(i=2*d-2;i>=d;i--){
         for(j=d;j>=1;j--){
             if(polcyclo[d-j]==-1)    mpf_add(x[i-j],x[i-j],x[i]);
             else if(polcyclo[d-j]==1)mpf_sub(x[i-j],x[i-j],x[i]);
         }
         mpf_set_ui(x[i],0);
     }
     return;
}

void c_general_reduce_f(long double x[],int d,int e,int expo)  {

    int i,e2=e/2;

     if(e%2==0)  {
       for(i=expo;i>=e2;i--)x[i-e2]-=x[i];
       expo=imin(expo,e2-1);
       if(e%3==0)  {
          int e3=e/3,e6=e/6;
          for(i=expo;i>=e3;i--)   {
              x[i-e3]-=x[i];
              x[i-e6]+=x[i]; 
          }
          expo=imin(expo,e3-1);
        }
    }

    long double t;

if(e==4){for(i=expo;i>=d;i--)x[i-2]-=x[i];}
else if(e==6){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-2]-=t;x[i-1]+=t;}}
else if(e==8){for(i=expo;i>=d;i--)x[i-4]-=x[i];}
else if(e==10){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==12){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-4]-=t;x[i-2]+=t;}}
else if(e==14){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==16){for(i=expo;i>=d;i--)x[i-8]-=x[i];}
else if(e==18){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-6]-=t;x[i-3]+=t;}}
else if(e==20){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-8]-=t;x[i-6]+=t;x[i-4]-=t;x[i-2]+=t;}}
else if(e==22){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-10]-=t;x[i-9]+=t;x[i-8]-=t;x[i-7]+=t;x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==24){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-8]-=t;x[i-4]+=t;}}
else if(e==26){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-12]-=t;x[i-11]+=t;x[i-10]-=t;x[i-9]+=t;x[i-8]-=t;x[i-7]+=t;x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==28){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-12]-=t;x[i-10]+=t;x[i-8]-=t;x[i-6]+=t;x[i-4]-=t;x[i-2]+=t;}}
else if(e==30){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-8]-=t;x[i-7]-=t;x[i-5]+=t;x[i-4]+=t;x[i-3]+=t;x[i-1]-=t;}}
else if(e==32){for(i=expo;i>=d;i--)x[i-16]-=x[i];}
else if(e==34){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-16]-=t;x[i-15]+=t;x[i-14]-=t;x[i-13]+=t;x[i-12]-=t;x[i-11]+=t;x[i-10]-=t;x[i-9]+=t;x[i-8]-=t;x[i-7]+=t;x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==36){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-12]-=t;x[i-6]+=t;}}
else if(e==38){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-18]-=t;x[i-17]+=t;x[i-16]-=t;x[i-15]+=t;x[i-14]-=t;x[i-13]+=t;x[i-12]-=t;x[i-11]+=t;x[i-10]-=t;x[i-9]+=t;x[i-8]-=t;x[i-7]+=t;x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==40){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-16]-=t;x[i-12]+=t;x[i-8]-=t;x[i-4]+=t;}}
else if(e==42){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-12]-=t;x[i-11]-=t;x[i-9]+=t;x[i-8]+=t;x[i-6]-=t;x[i-4]+=t;x[i-3]+=t;x[i-1]-=t;}}
else if(e==44){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-20]-=t;x[i-18]+=t;x[i-16]-=t;x[i-14]+=t;x[i-12]-=t;x[i-10]+=t;x[i-8]-=t;x[i-6]+=t;x[i-4]-=t;x[i-2]+=t;}}
else if(e==48){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-16]-=t;x[i-8]+=t;}}
else if(e==50){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-20]-=t;x[i-15]+=t;x[i-10]-=t;x[i-5]+=t;}}
else if(e==54){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-18]-=t;x[i-9]+=t;}}
else if(e==60){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-16]-=t;x[i-14]-=t;x[i-10]+=t;x[i-8]+=t;x[i-6]+=t;x[i-2]-=t;}}
else if(e==66){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-20]-=t;x[i-19]-=t;x[i-17]+=t;x[i-16]+=t;x[i-14]-=t;x[i-13]-=t;x[i-11]+=t;x[i-10]+=t;x[i-9]+=t;x[i-7]-=t;x[i-6]-=t;x[i-4]+=t;x[i-3]+=t;x[i-1]-=t;}}
else if(e==70){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-24]-=t;x[i-23]-=t;x[i-19]+=t;x[i-18]+=t;x[i-17]+=t;x[i-16]+=t;x[i-14]-=t;x[i-13]-=t;x[i-12]-=t;x[i-11]-=t;x[i-10]-=t;x[i-8]+=t;x[i-7]+=t;x[i-6]+=t;x[i-5]+=t;x[i-1]-=t;}}
else if(e==84){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-24]-=t;x[i-22]-=t;x[i-18]+=t;x[i-16]+=t;x[i-12]-=t;x[i-8]+=t;x[i-6]+=t;x[i-2]-=t;}}
else if(e==90){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-24]-=t;x[i-21]-=t;x[i-15]+=t;x[i-12]+=t;x[i-9]+=t;x[i-3]-=t;}}

     return;
}

void c_general_reduce_z(lli x[],int d,int e,int expo)  {
    int i,e2=e/2;

    if(e%2==0)  {
       for(i=expo;i>=e2;i--)x[i-e2]-=x[i];
       expo=imin(expo,e2-1);
       if(e%3==0)  {
          int e3=e/3,e6=e/6;
          for(i=expo;i>=e3;i--)   {
              x[i-e3]-=x[i];
              x[i-e6]+=x[i]; 
          }
          expo=imin(expo,e3-1);
        }
    }
    lli t;

if(e==4){for(i=expo;i>=d;i--)x[i-2]-=x[i];}
else if(e==6){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-2]-=t;x[i-1]+=t;}}
else if(e==8){for(i=expo;i>=d;i--)x[i-4]-=x[i];}
else if(e==10){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==12){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-4]-=t;x[i-2]+=t;}}
else if(e==14){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==16){for(i=expo;i>=d;i--)x[i-8]-=x[i];}
else if(e==18){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-6]-=t;x[i-3]+=t;}}
else if(e==20){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-8]-=t;x[i-6]+=t;x[i-4]-=t;x[i-2]+=t;}}
else if(e==22){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-10]-=t;x[i-9]+=t;x[i-8]-=t;x[i-7]+=t;x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==24){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-8]-=t;x[i-4]+=t;}}
else if(e==26){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-12]-=t;x[i-11]+=t;x[i-10]-=t;x[i-9]+=t;x[i-8]-=t;x[i-7]+=t;x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==28){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-12]-=t;x[i-10]+=t;x[i-8]-=t;x[i-6]+=t;x[i-4]-=t;x[i-2]+=t;}}
else if(e==30){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-8]-=t;x[i-7]-=t;x[i-5]+=t;x[i-4]+=t;x[i-3]+=t;x[i-1]-=t;}}
else if(e==32){for(i=expo;i>=d;i--)x[i-16]-=x[i];}
else if(e==34){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-16]-=t;x[i-15]+=t;x[i-14]-=t;x[i-13]+=t;x[i-12]-=t;x[i-11]+=t;x[i-10]-=t;x[i-9]+=t;x[i-8]-=t;x[i-7]+=t;x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==36){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-12]-=t;x[i-6]+=t;}}
else if(e==38){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-18]-=t;x[i-17]+=t;x[i-16]-=t;x[i-15]+=t;x[i-14]-=t;x[i-13]+=t;x[i-12]-=t;x[i-11]+=t;x[i-10]-=t;x[i-9]+=t;x[i-8]-=t;x[i-7]+=t;x[i-6]-=t;x[i-5]+=t;x[i-4]-=t;x[i-3]+=t;x[i-2]-=t;x[i-1]+=t;}}
else if(e==40){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-16]-=t;x[i-12]+=t;x[i-8]-=t;x[i-4]+=t;}}
else if(e==42){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-12]-=t;x[i-11]-=t;x[i-9]+=t;x[i-8]+=t;x[i-6]-=t;x[i-4]+=t;x[i-3]+=t;x[i-1]-=t;}}
else if(e==44){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-20]-=t;x[i-18]+=t;x[i-16]-=t;x[i-14]+=t;x[i-12]-=t;x[i-10]+=t;x[i-8]-=t;x[i-6]+=t;x[i-4]-=t;x[i-2]+=t;}}
else if(e==48){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-16]-=t;x[i-8]+=t;}}
else if(e==50){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-20]-=t;x[i-15]+=t;x[i-10]-=t;x[i-5]+=t;}}
else if(e==54){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-18]-=t;x[i-9]+=t;}}
else if(e==60){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-16]-=t;x[i-14]-=t;x[i-10]+=t;x[i-8]+=t;x[i-6]+=t;x[i-2]-=t;}}
else if(e==66){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-20]-=t;x[i-19]-=t;x[i-17]+=t;x[i-16]+=t;x[i-14]-=t;x[i-13]-=t;x[i-11]+=t;x[i-10]+=t;x[i-9]+=t;x[i-7]-=t;x[i-6]-=t;x[i-4]+=t;x[i-3]+=t;x[i-1]-=t;}}
else if(e==70){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-24]-=t;x[i-23]-=t;x[i-19]+=t;x[i-18]+=t;x[i-17]+=t;x[i-16]+=t;x[i-14]-=t;x[i-13]-=t;x[i-12]-=t;x[i-11]-=t;x[i-10]-=t;x[i-8]+=t;x[i-7]+=t;x[i-6]+=t;x[i-5]+=t;x[i-1]-=t;}}
else if(e==84){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-24]-=t;x[i-22]-=t;x[i-18]+=t;x[i-16]+=t;x[i-12]-=t;x[i-8]+=t;x[i-6]+=t;x[i-2]-=t;}}
else if(e==90){for(i=expo;i>=d;i--)if(x[i]!=0){t=x[i];x[i-24]-=t;x[i-21]-=t;x[i-15]+=t;x[i-12]+=t;x[i-9]+=t;x[i-3]-=t;}}

     return;
}

void c_reduce_f(long double x[],int d,int e)  {
     c_general_reduce_f(x,d,e,2*d-2);
     return;
}

void reduce_z(mpz_t x[],int d,int e)  {
     int i,j;
     
     for(i=2*d-2;i>=d;i--)
         if(mpz_sgn(x[i])!=0)  {
            for(j=d;j>=1;j--){
               if(polcyclo[d-j]==-1)    mpz_add(x[i-j],x[i-j],x[i]);
               else if(polcyclo[d-j]==1)mpz_sub(x[i-j],x[i-j],x[i]);
            }
            mpz_set_ui(x[i],0);
         }
     return;
}

void c_reduce_z(lli x[],int d,int e)  {

     c_general_reduce_z(x,d,e,2*d-2);
     return;
}

void bigreduce_f(mpf_t x[],int d,int e)  {
     int i,j,expo;
     
     if(e%2==0)  {
        for(i=e-1;i>=e/2;i--){
            mpf_sub(x[i-e/2],x[i-e/2],x[i]);
            mpf_set_ui(x[i],0);
        }
        expo=e/2-1;
     }
     else expo=e-1;
     
     for(i=expo;i>=d;i--){
         for(j=d;j>=1;j--){
            if(polcyclo[d-j]==-1)    mpf_add(x[i-j],x[i-j],x[i]);
            else if(polcyclo[d-j]==1)mpf_sub(x[i-j],x[i-j],x[i]);
         }
         mpf_set_ui(x[i],0);
     }
     return;
}

void c_bigreduce_f(long double x[],int d,int e)  {

    c_general_reduce_f(x,d,e,e-1);
    return;
}

void bigreduce_z(mpz_t x[],int d,int e)  {
     int i,j,expo;
     
     if(e%2==0)  {
        for(i=e-1;i>=e/2;i--){
            mpz_sub(x[i-e/2],x[i-e/2],x[i]);
            mpz_set_ui(x[i],0);
        }
        expo=e/2-1;
     }
     else expo=e-1;

     for(i=expo;i>=d;i--){
         for(j=d;j>=1;j--){
            if(polcyclo[d-j]==-1)    mpz_add(x[i-j],x[i-j],x[i]);
            else if(polcyclo[d-j]==1)mpz_sub(x[i-j],x[i-j],x[i]);
         }
         mpz_set_ui(x[i],0);
     }
     return;
}

void c_bigreduce_z(lli x[],int d,int e)  {

     c_general_reduce_z(x,d,e,e-1);
     return;
}

void sub_z(mpz_t z[],mpz_t x[],mpz_t y[],int n)  {

     int i;
     for(i=0;i<n;i++)mpz_sub(z[i],x[i],y[i]);
     return;
}

void c_sub_z(lli z[],lli x[],lli y[],int n)  {

     int i;
     for(i=0;i<n;i++)z[i]=x[i]-y[i];
     return;
}

void mul_z(mpz_t z[],mpz_t x[],mpz_t y[],int d,int e)  {
// compute z=x*y mod polcyclo(e)
     int i,j,deg1,deg2,sg;
     unsigned long int ui;
     mpz_t temp,t[2*d-1];
     mpz_init(temp);
     
     for(i=0;i<=2*d-2;i++)mpz_init_set_ui(t[i],0);
     
     deg1=d-1;while(deg1>0&&mpz_sgn(x[deg1])==0)deg1--;
     deg2=d-1;while(deg2>0&&mpz_sgn(y[deg2])==0)deg2--;
     
     for(j=0;j<=deg2;j++)  {
         sg=mpz_sgn(y[j]);
         if(sg>0)  {
            if(mpz_cmp_ui(y[j],1)==0)         {for(i=0;i<=deg1;i++)mpz_add(t[i+j],t[i+j],x[i]);}
            else if(mpz_fits_ulong_p(y[j])!=0){ui=mpz_get_ui(y[j]);for(i=0;i<=deg1;i++)mpz_addmul_ui(t[i+j],x[i],ui);}
            else                               {for(i=0;i<=deg1;i++)mpz_addmul(t[i+j],x[i],y[j]);}
         }
         else if(sg<0)  {
            if(mpz_cmp_si(y[j],-1)==0)        {for(i=0;i<=deg1;i++)mpz_sub(t[i+j],t[i+j],x[i]);}
            else {
               mpz_neg(temp,y[j]);
               if(mpz_fits_ulong_p(temp)!=0)  {ui=mpz_get_ui(temp);for(i=0;i<=deg1;i++)mpz_submul_ui(t[i+j],x[i],ui);}
               else                           {for(i=0;i<=deg1;i++)mpz_submul(t[i+j],x[i],temp);}
           }
        }
    }

    mpz_clear(temp);
    reduce_z(t,d,e);
    for(i=0;i<d;i++)mpz_set(z[i],t[i]);
    for(i=0;i<=2*d-2;i++)mpz_clear(t[i]);

    return;
}            

void c_mul_z(lli z[],lli x[],lli y[],int d,int e)  {
// compute z=x*y mod polcyclo(e)
     int i,j,deg1,deg2;
     lli t[2*d-1],temp;
     
     for(i=0;i<=2*d-2;i++)t[i]=0;
     
     deg1=d-1;while(deg1>0&&x[deg1]==0)deg1--;
     deg2=d-1;while(deg2>0&&y[deg2]==0)deg2--;
     
     for(j=0;j<=deg2;j++)  {
         if(y[j]==1)       {for(i=0;i<=deg1;i++)t[i+j]+=x[i];}
         else if(y[j]==-1){for(i=0;i<=deg1;i++)t[i+j]-=x[i];}
         else if(y[j]!=0) {temp=y[j];for(i=0;i<=deg1;i++)t[i+j]+=temp*x[i];}
    }

    c_reduce_z(t,d,e);
    for(i=0;i<d;i++)z[i]=t[i];

    return;
}

void embed_f(mpf_t y[][2],mpf_t x[],int d,int e)  {

    int i,j,res;
    mpf_t temp;
    mpf_init(temp);
    
    for(j=0;j<d/2;j++)  {
        mpf_set_ui(y[j][0],0);
        mpf_set_ui(y[j][1],0);
        for(i=0;i<d;i++)  {
            res=(i*l_array[j])%e;
            mpf_mul(temp,R_array[res][0],x[i]);mpf_add(y[j][0],y[j][0],temp);
            mpf_mul(temp,R_array[res][1],x[i]);mpf_add(y[j][1],y[j][1],temp);
        }
    }
    mpf_clear(temp);

    return;
}

void c_embed_f(long double y[][2],long double x[],int d,int e)  {

    int i,j,res,d2=d/2;
    long double r0,r1;
    
    for(j=0;j<d2;j++)  {
        r0=0;r1=0;
        for(i=0;i<d;i++)  {
            res=i_mul_l_array[i][j];
            r0+=c_R_array[res][0]*x[i];
            r1+=c_R_array[res][1]*x[i];
        }
        y[j][0]=r0;
        y[j][1]=r1;
    }
    return;
}

void embed_z(mpf_t y[][2],mpz_t x[],int d,int e)  {

    int i,j,res;
    mpf_t t,temp;
    mpf_init(t);
    mpf_init(temp);
    
    for(j=0;j<d/2;j++)  {
        mpf_set_ui(y[j][0],0);
        mpf_set_ui(y[j][1],0);
        for(i=0;i<d;i++)  {
            res=(i*l_array[j])%e;
            mpf_set_z(t,x[i]);
            mpf_mul(temp,R_array[res][0],t);mpf_add(y[j][0],y[j][0],temp);
            mpf_mul(temp,R_array[res][1],t);mpf_add(y[j][1],y[j][1],temp);
        }
    }
    mpf_clear(t);
    mpf_clear(temp);

    return;
}

void c_embed_z(long double y[][2],lli x[],int d,int e)  {

    int i,j,res,d2=d/2;
    long double r0,r1;
    
    for(j=0;j<d2;j++)  {
        r0=0;r1=0;
        for(i=0;i<d;i++)  {
            res=i_mul_l_array[i][j];
            r0+=c_R_array[res][0]*(long double)x[i];
            r1+=c_R_array[res][1]*(long double)x[i];
        }
        y[j][0]=r0;
        y[j][1]=r1;
    }
    return;
}

void unembed_f(mpf_t y[],mpf_t x[][2],int d,int e)  {
    
    int i,j,res;
    mpf_t temp,t[e];
    mpf_init(temp);
    for(i=0;i<e;i++)mpf_init_set_ui(t[i],0);
    
    for(i=0;i<e;i++)  {
        for(j=0;j<d/2;j++)  {
            res=((e-l_array[j])*i)%e;
            mpf_mul(temp,x[j][0],R_array[res][0]);mpf_add(t[i],t[i],temp);
            mpf_mul(temp,x[j][1],R_array[res][1]);mpf_sub(t[i],t[i],temp);
        }
        mpf_mul_2exp(t[i],t[i],1);
        mpf_div_ui(t[i],t[i],e);
    }
 
    bigreduce_f(t,d,e);
    for(i=0;i<d;i++)mpf_set(y[i],t[i]);
    
    for(i=0;i<e;i++)mpf_clear(t[i]);
    mpf_clear(temp);

    return;
}

void c_unembed_f(long double y[],long double x[][2],int d,int e)  {

    int i,j,res,d1=d-1,d2=d/2,e2=e/2;
    long double t[e],r0,r1,mult=(long double)2/e;

    for(i=0;i<=e/4;i++)  {
        r0=0;r1=0;
        for(j=0;j<d2;j++)  {
            res=i_mul_l_array[i][d1-j];
            r0+=x[j][0]*c_R_array[res][0];
            r1+=x[j][1]*c_R_array[res][1];
        }
        t[i]=mult*(r0-r1);
        t[e2-i]=mult*(-r0-r1);
    }
    for(i=e2+1;i<e;i++)t[i]=-t[i-e2];

    c_bigreduce_f(t,d,e);
    for(i=0;i<d;i++)y[i]=t[i];
    return;
}

void balance(mpz_t x[],int d,int e)  {
    
    int i,j,iw;
    double dd,v[d/2],w[d/2];
    mpf_t t,ex[d/2][2];
  
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_init(ex[i][j]);
    mpf_init(t);
    embed_z(ex,x,d,e);
    
    for(i=0;i<d/2;i++){
        abs_complex_f(t,ex[i][0],ex[i][1]);
        v[i]=log_f(t);
    }
    
    for(i=0;i<d/2-1;i++){
        dd=0.0;
        for(j=0;j<d/2;j++)dd+=MM[i][j]*v[j];
        w[i]=dd;
    }
    
    for(i=0;i<length_U1;i++)  {
        dd=w[i];
        if(dd>=0.0)  iw=(int) ((double) dd+0.5);
        else         iw=(int) ((double) dd-0.5);
        
        while(iw>0)  {
               if(iw<=max_exponent){mul_z(x,x,U2pow[i][iw],d,e);iw=0;}
               else                {mul_z(x,x,U2pow[i][max_exponent],d,e);iw-=max_exponent;}
        }
        while(iw<0)  {
               if(iw>=-max_exponent){mul_z(x,x,U1pow[i][-iw],d,e);iw=0;}
               else                {mul_z(x,x,U1pow[i][max_exponent],d,e);iw+=max_exponent;}
        }
    }
    
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_clear(ex[i][j]);
    mpf_clear(t);
    return;
}    

void c_balance(lli x[],int d,int e)  {
    
    int i,j,iw,d2=d/2;
    double dd,v[d2],w[d2];
    long double t,ex[d2][2];
  
    c_embed_z(ex,x,d,e);
    
    for(i=0;i<d2;i++){
        t=c_abs_complex_f(ex[i][0],ex[i][1]);
        v[i]=log(t);
    }
    
    for(i=0;i<d2-1;i++){
        dd=0.0;
        for(j=0;j<d2;j++)dd+=MM[i][j]*v[j];
        w[i]=dd;
    }
    
    for(i=0;i<length_U1;i++)  {
        dd=w[i];
        if(dd>=0.0)  iw=(int) ((double) dd+0.5);
        else         iw=(int) ((double) dd-0.5);
        
        while(iw>0)  {
               if(iw<=max_exponent){c_mul_z(x,x,c_U2pow[i][iw],d,e);iw=0;}
               else                {c_mul_z(x,x,c_U2pow[i][max_exponent],d,e);iw-=max_exponent;}
        }
        while(iw<0)  {
               if(iw>=-max_exponent){c_mul_z(x,x,c_U1pow[i][-iw],d,e);iw=0;}
               else                {c_mul_z(x,x,c_U1pow[i][max_exponent],d,e);iw+=max_exponent;}
        }
    }
    
    return;
}    

void prodnorm_f(mpf_ptr norm,mpf_t x[][2],int n)  {
    
    int i;
    mpf_t re,re2,im,im2,temp;
    mpf_init(re);
    mpf_init(re2);
    mpf_init(im);
    mpf_init(im2);
    mpf_init(temp);
    
    mpf_set_ui(re,1);
    mpf_set_ui(im,0);
    for(i=0;i<n;i++)  {
        mpf_set(re2,re);
        mpf_set(im2,im);
        
        mpf_mul(re,re2,x[i][0]);
        mpf_mul(temp,im2,x[i][1]);
        mpf_sub(re,re,temp);
        
        mpf_mul(im,re2,x[i][1]);
        mpf_mul(temp,im2,x[i][0]);
        mpf_add(im,im,temp);
   }
   
   norm_complex_f(norm,re,im);
   
   mpf_clear(re);
   mpf_clear(re2);
   mpf_clear(im);
   mpf_clear(im2);
   mpf_clear(temp);
   
   return;
}

long double c_prodnorm_f(long double x[][2],int n)  {
    
    int i;
    long double re,re2,im,im2;
    
    re=1;
    im=0;
    for(i=0;i<n;i++)  {
        re2=re;
        im2=im;
        
        re=re2*x[i][0]-im2*x[i][1];
        im=re2*x[i][1]+im2*x[i][0];
   }
   
   return c_norm_complex_f(re,im);
}

void swap_multi_arrays_f(mpf_t x[][2],mpf_t y[][2],int n)  {
    
    int i,j;
    for(i=0;i<n;i++)for(j=0;j<2;j++)mpf_swap(x[i][j],y[i][j]);
    return;
}

void c_swap_multi_arrays_f(long double x[][2],long double y[][2],int n)  {
    
    int i,j;
    long double temp;
    for(i=0;i<n;i++)for(j=0;j<2;j++){temp=x[i][j];x[i][j]=y[i][j];y[i][j]=temp;}
    return;
}

void swap_arrays_z(mpz_t x[],mpz_t y[],int n)  {
    
    int i;
    for(i=0;i<n;i++)mpz_swap(x[i],y[i]);
    return;
}

void c_swap_arrays_z(lli x[],lli y[],int n)  {
    
    int i;
    lli temp;
    for(i=0;i<n;i++){temp=x[i];x[i]=y[i];y[i]=temp;}
    return;
}

void set_arrays_f(mpf_t x[],mpf_t y[],int n)  {
    
    int i;
    for(i=0;i<n;i++)mpf_set(x[i],y[i]);
    return;
}

void c_set_arrays_f(long double x[],long double y[],int n)  {
    
    int i;
    for(i=0;i<n;i++)x[i]=y[i];
    return;
}

void set_arrays_z(mpz_t x[],mpz_t y[],int n)  {
    
    int i;
    for(i=0;i<n;i++)mpz_set(x[i],y[i]);
    return;
}

void c_set_arrays_z(lli x[],lli y[],int n)  {
    
    int i;
    for(i=0;i<n;i++)x[i]=y[i];
    return;
}

void set_multi_arrays_f(mpf_t x[][2],mpf_t y[][2],int n)  {
    
    int i,j;
    for(i=0;i<n;i++)for(j=0;j<2;j++)mpf_set(x[i][j],y[i][j]);
    return;
}

void c_set_multi_arrays_f(long double x[][2],long double y[][2],int n)  {
    
    int i,j;
    for(i=0;i<n;i++)for(j=0;j<2;j++)x[i][j]=y[i][j];
    return;
}

void abs_complex_f(mpf_ptr ans,mpf_t re,mpf_t im)  {
// return with sqrt(re^2+im^2)
    
    norm_complex_f(ans,re,im);
    mpf_sqrt(ans,ans);
    
    return;
}

long double c_abs_complex_f(long double re,long double im)  {
// return with sqrt(re^2+im^2)
    
    return sqrt(re*re+im*im);
}

void abs_complex_z(mpf_ptr ans,mpz_t re,mpz_t im)  {
// return with sqrt(re^2+im^2)
    mpf_t temp;
    mpf_init(temp);
    
    mpf_set_z(ans,re);
    mpf_set_z(temp,im);
    mpf_pow_ui(ans,ans,2);
    mpf_pow_ui(temp,temp,2);
    mpf_add(ans,ans,temp);
    mpf_sqrt(ans,ans);
    
    mpf_clear(temp);

    return;
}

long double c_abs_complex_z(lli re,lli im)  {
// return with sqrt(re^2+im^2)
    long double dre=(long double)re,dim=(long double)im;
    
    return sqrt(dre*dre+dim*dim);
}

void norm_complex_f(mpf_ptr ans,mpf_t re,mpf_t im)  {
// return with re^2+im^2
    mpf_t t1,t2;
    mpf_init(t1);
    mpf_init(t2);
    
    mpf_pow_ui(t1,re,2);
    mpf_pow_ui(t2,im,2);
    mpf_add(ans,t1,t2);
    
    mpf_clear(t1);
    mpf_clear(t2);

    return;
}

long double c_norm_complex_f(long double re,long double im)  {
// return with re^2+im^2
    return re*re+im*im;
}

void div_complex(mpf_ptr re,mpf_ptr im,mpf_t re1,mpf_t im1,mpf_t re2,mpf_t im2)  {
// compute (re1+I*im1)/(re2+I*im2)
    mpf_t temp,temp2,r,i;
    mpf_init(temp);
    mpf_init(temp2);
    mpf_init(r);
    mpf_init(i);

    mpf_mul(r,re1,re2);
    mpf_mul(temp,im1,im2);
    mpf_add(r,r,temp);
    
    mpf_mul(i,im1,re2);
    mpf_mul(temp,re1,im2);
    mpf_sub(i,i,temp);
    
    mpf_pow_ui(temp,re2,2);
    mpf_pow_ui(temp2,im2,2);
    mpf_add(temp,temp,temp2);
    
    mpf_div(re,r,temp);
    mpf_div(im,i,temp);

    mpf_clear(temp);
    mpf_clear(temp2);
    mpf_clear(r);
    mpf_clear(i);
    
    return;
}

void c_div_complex(long double *re,long double *im,long double re1,long double im1,long double re2,long double im2)  {
// compute (re1+I*im1)/(re2+I*im2)
   
    long double nn=re2*re2+im2*im2;
    *re=(re1*re2+im1*im2)/nn;
    *im=(im1*re2-re1*im2)/nn;
    
    return;
}

double log_f(mpf_t x)  {
// return with log(x), assume that x>0
    
    signed long int exponent[4];
    double dd=mpf_get_d_2exp(exponent,x);        
   
    return log(dd)+(double) LOG2*exponent[0];
}

void pol_norm_z(mpf_ptr norm,mpz_t x[],int d,int e)  {
    
    int i,j,d2=d/2;
    mpf_t ex[d2][2];
    for(i=0;i<d2;i++)for(j=0;j<2;j++)mpf_init(ex[i][j]);
    embed_z(ex,x,d,e);
    prodnorm_f(norm,ex,d/2);
    
    for(i=0;i<d2;i++)for(j=0;j<2;j++)mpf_clear(ex[i][j]);
    return;
}

int pol_gcd(mpz_t ans[],mpz_t x[],mpz_t y[],lli p,int d,int e,int balanced,int fiddle,lli gen,int stat)  {

    int i,j,all_zero;
    int partial_count=0;
    int count_iterations=0;
    int count_failed=0;
    int count_balance=0;
    int ret=0,res,s;
    double dd;
    
    mpz_t iq[d],z[d],x2[d],y2[d],temp_z;
    mpf_t ex[d/2][2],ey[d/2][2],ez[d/2][2],u[d/2][2],ec[d/2][2],ed[d/2][2],q[d],c[d],fd[d],t[d],nx,ny,nz,nc,nd,temp,temp2;
    for(i=0;i<d;i++)mpz_init(iq[i]);
    for(i=0;i<d;i++)mpz_init(z[i]);
    for(i=0;i<d;i++)mpz_init(x2[i]);
    for(i=0;i<d;i++)mpz_init(y2[i]);
    mpz_init(temp_z);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_init(ex[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_init(ey[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_init(ez[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_init(u[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_init(ec[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_init(ed[i][j]);
    for(i=0;i<d;i++)mpf_init(q[i]);
    for(i=0;i<d;i++)mpf_init(c[i]);
    for(i=0;i<d;i++)mpf_init(fd[i]);
    for(i=0;i<d;i++)mpf_init(t[i]);
    mpf_init(nx);
    mpf_init(ny);
    mpf_init(nz);
    mpf_init(nc);
    mpf_init(nd);
    mpf_init(temp);
    mpf_init(temp2);

    set_arrays_z(x2,x,d);
    set_arrays_z(y2,y,d);

    embed_z(ex,x,d,e);
    embed_z(ey,y,d,e);

    prodnorm_f(nx,ex,d/2);
    prodnorm_f(ny,ey,d/2);
    
    while(1)  {
          partial_count++;
          count_iterations++;

          if(mpf_cmp(nx,ny)<0)  {
             swap_arrays_z(x,y,d);
             mpf_swap(nx,ny);
             swap_multi_arrays_f(ex,ey,d/2);
          }
          
          for(i=0;i<d/2;i++)
              div_complex(u[i][0],u[i][1],ex[i][0],ex[i][1],ey[i][0],ey[i][1]);
          
          unembed_f(t,u,d,e);
          
          for(i=0;i<d;i++){
              mpf_floor(temp,t[i]);
              mpz_set_f(iq[i],temp);
              mpf_sub(temp2,t[i],temp);
              dd=mpf_get_d(temp2);
              if(dd>0.5)mpz_add_ui(iq[i],iq[i],1);
          }
          
          if(fiddle)  {
             for(i=0;i<d;i++)  {
                 mpf_set_z(fd[i],iq[i]);
                 mpf_sub(fd[i],fd[i],t[i]);
             }
             
             
             embed_f(ed,fd,d,e);
             prodnorm_f(nd,ed,d/2);
             
             set_arrays_f(c,fd,d);
             set_multi_arrays_f(ec,ed,d/2);
             
             for(i=0;i<d;i++){
                 mpf_neg(temp,fd[i]);
                 if(mpf_cmp_d(fd[i],block_eps)>0||mpf_cmp_d(temp,block_eps)>0)  {
                    if(mpf_cmp_d(fd[i],block_eps)>0)s=-1;
                    else s=1;
                    if(s==1){
                        mpf_add_ui(c[i],c[i],1);
                        for(j=0;j<d/2;j++){
                            res=(l_array[j]*i)%e;
                            mpf_add(ec[j][0],ed[j][0],R_array[res][0]);
                            mpf_add(ec[j][1],ed[j][1],R_array[res][1]);
                        }
                    }
                    else  {
                        mpf_sub_ui(c[i],c[i],1);
                        for(j=0;j<d/2;j++){
                            res=(l_array[j]*i)%e;
                            mpf_sub(ec[j][0],ed[j][0],R_array[res][0]);
                            mpf_sub(ec[j][1],ed[j][1],R_array[res][1]);
                        }
                    }
                    prodnorm_f(nc,ec,d/2);
                    mpf_set_d(temp,block_eps2);
                    mpf_mul(temp,temp,nd);
                    if(mpf_cmp(nc,temp)<0)  {
                       if(s==1){mpz_add_ui(iq[i],iq[i],1);mpf_add_ui(fd[i],fd[i],1);}
                       else    {mpz_sub_ui(iq[i],iq[i],1);mpf_sub_ui(fd[i],fd[i],1);}
                       set_multi_arrays_f(ed,ec,d/2);
                       mpf_set(nd,nc);
                    }
                    else if(s==1)  mpf_sub_ui(c[i],c[i],1);
                    else mpf_add_ui(c[i],c[i],1);
               }}
          }          

          mul_z(iq,iq,y,d,e);
          sub_z(z,x,iq,d);

          all_zero=1;
          for(i=0;i<d;i++)
              if(mpz_sgn(z[i])!=0){all_zero=0;break;}
          
          if(all_zero)  {
             balance(y,d,e);
             set_arrays_z(ans,y,d);

	    if(stat)  {
               printf("iterations=%d\n",count_iterations);
               printf("    failed=%d\n",count_failed);
               printf("  balanced=%d\n",count_balance);
             }  
	     
             ret=1;
             break;
          }
          
          embed_z(ez,z,d,e);
          prodnorm_f(nz,ez,d/2);

          if(balanced)  {
             
             mpz_set_ui(temp_z,0);
             for(i=0;i<d;i++)  {
                 if(mpz_sgn(z[i])>0)mpz_add(temp_z,temp_z,z[i]);
                 else mpz_sub(temp_z,temp_z,z[i]);
             }

             mpf_set_z(temp,temp_z);
             mpf_div_ui(temp,temp,10*d);
             mpf_pow_ui(temp,temp,d);
             
             if(mpf_cmp(temp,nz)>=0)  {
                count_balance++;
                balance(z,d,e);
                embed_z(ez,z,d,e);
             }
          }
          
          if(mpf_cmp(nz,ny)<0)  {
             set_arrays_z(x,z,d);
             set_multi_arrays_f(ex,ez,d/2);
             mpf_set(nx,nz);
          }
          else  {
             gen=getrandom(gen);
             i=gen%len_SS;
             mul_z(z,y,SS2[i],d,e);
             all_zero=1;
             for(j=0;j<d;j++)
                 if(mpz_divisible_ui_p(z[j],NS)==0)
                    {all_zero=0;break;}
             if(all_zero)  {
                for(j=0;j<d;j++)
                    mpz_divexact_ui(y[j],z[j],NS);
                embed_z(ey,y,d,e);
                prodnorm_f(ny,ey,d/2);
             }
             else  {
                count_failed++;
                mul_z(x,x,SS[i],d,e);
                embed_z(ex,x,d,e);
                prodnorm_f(nx,ex,d/2);
             }
         }
         if(partial_count==max_iterations)  {
            partial_count=0;
            set_arrays_z(x,x2,d);
            set_arrays_z(y,y2,d);
            embed_z(ex,x,d,e);
            embed_z(ey,y,d,e);
            prodnorm_f(nx,ex,d/2);
            prodnorm_f(ny,ey,d/2);
         }
    }
    
    for(i=0;i<d;i++)mpz_clear(iq[i]);
    for(i=0;i<d;i++)mpz_clear(z[i]);
    for(i=0;i<d;i++)mpz_clear(x2[i]);
    for(i=0;i<d;i++)mpz_clear(y2[i]);
    mpz_clear(temp_z);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_clear(ex[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_clear(ey[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_clear(ez[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_clear(u[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_clear(ec[i][j]);
    for(i=0;i<d/2;i++)for(j=0;j<2;j++)mpf_clear(ed[i][j]);
    for(i=0;i<d;i++)mpf_clear(q[i]);
    for(i=0;i<d;i++)mpf_clear(c[i]);
    for(i=0;i<d;i++)mpf_clear(fd[i]);
    for(i=0;i<d;i++)mpf_clear(t[i]);
    mpf_clear(nx);
    mpf_clear(ny);
    mpf_clear(nz);
    mpf_clear(nc);
    mpf_clear(nd);
    mpf_clear(temp);
    mpf_clear(temp2);

    return ret;
}

int c_pol_gcd(lli ans[],lli x[],lli y[],lli p,int d,int e,int balanced,int fiddle,lli gen,int stat)  {

    int i,j,all_zero,d2=d/2;
    int partial_count=0;
    int count_iterations=0;
    int count_failed=0;
    int count_balance=0;
    int ret=0,s,test;
    
    lli iq[d],z[d],x2[d],y2[d],res,temp_z,ix0,iy0,mult;
    long double diff,ex[d2][2],ey[d2][2],ez[d2][2],u[d2][2],ec[d2][2],ed[d2][2],c[d],fd[d],t[d],nx,ny,nz,nc,nd,temp;

    c_set_arrays_z(x2,x,d);
    c_set_arrays_z(y2,y,d);

    test=1;
    for(i=2;i<d;i++)if(x[i]!=0||y[i]!=0)test=0;

    if(test)  {
      while(1)  {
       if(iabs(x[0])<iabs(y[0])){
         temp=x[0];x[0]=y[0];y[0]=temp;
         temp=x[1];x[1]=y[1];y[1]=temp;
       }
       ix0=iabs(x[0]);
       iy0=iabs(y[0]);
       if(ix0<iabs(x[1])||ix0<iabs(y[1])||x[0]==0||y[0]==0)break;

       mult=(2*ix0+iy0)/(2*iy0);
       if((x[0]>0&&y[0]<0)||(x[0]<0&&y[0]>0))mult=-mult;

       x[0]-=mult*y[0];
       x[1]-=mult*y[1];
      }
    }

    c_embed_z(ex,x,d,e);
    nx=c_prodnorm_f(ex,d2);
    
    if(e==4||e==6){
             c_set_arrays_z(ans,x,d);

             mpz_t a[d],ztemp;
             for(i=0;i<d;i++){mpz_init(a[i]);longlongtompz(a[i],ans[i]);}
             mpz_init(ztemp);
             mpf_t na,ftemp;
             mpf_init(na);
             mpf_init(ftemp);

             pol_norm_z(na,a,d,e);
             longlongtompz(ztemp,p);
             mpf_set_z(ftemp,ztemp);
             mpf_sub(ftemp,ftemp,na);
             mpf_abs(ftemp,ftemp);

             for(i=0;i<d;i++)mpz_clear(a[i]);
             mpz_clear(ztemp);
             mpf_clear(na);

             if(mpf_cmp_d(ftemp,0.4)<0)  {mpf_clear(ftemp);return 1;}
             mpf_clear(ftemp);
    }

    c_embed_z(ey,y,d,e);
    ny=c_prodnorm_f(ey,d2);


    while(1)  {
          partial_count++;
          count_iterations++;
         
         if(nx<ny)  {
             c_swap_arrays_z(x,y,d);
             temp=nx;nx=ny;ny=temp;
             c_swap_multi_arrays_f(ex,ey,d/2);
          }
          
          for(i=0;i<d2;i++)
              c_div_complex(&u[i][0],&u[i][1],ex[i][0],ex[i][1],ey[i][0],ey[i][1]);

	  c_unembed_f(t,u,d,e);
          
          for(i=0;i<d;i++){
              iq[i]=(lli) t[i];
              if((long double)iq[i]>t[i])iq[i]--;
              diff=(long double) t[i]-iq[i];
              if(diff>0.5)iq[i]++;
          }
          
          if(fiddle)  {
             for(i=0;i<d;i++)
                 fd[i]=((long double)iq[i])-t[i];

             c_embed_f(ed,fd,d,e);
             nd=c_prodnorm_f(ed,d2);
             
             c_set_arrays_f(c,fd,d);
             c_set_multi_arrays_f(ec,ed,d2);
             
             for(i=0;i<d;i++){
                 if(fd[i]>block_eps||fd[i]<-block_eps)  {
                    if(fd[i]>block_eps)s=-1;
                    else s=1;
                    if(s==1){
                        c[i]++;
                        for(j=0;j<d2;j++){
                            res=i_mul_l_array[i][j];
                            ec[j][0]=ed[j][0]+c_R_array[res][0];
                            ec[j][1]=ed[j][1]+c_R_array[res][1];
                        }
                    }
                    else  {
                        c[i]--;
                        for(j=0;j<d2;j++){
                            res=i_mul_l_array[i][j];
                            ec[j][0]=ed[j][0]-c_R_array[res][0];
                            ec[j][1]=ed[j][1]-c_R_array[res][1];
                        }
                    }
                    nc=c_prodnorm_f(ec,d2);
                    if(nc<(long double)block_eps2*nd)  {
                       if(s==1){iq[i]++;fd[i]++;}
                       else    {iq[i]--;fd[i]--;}
                       c_set_multi_arrays_f(ed,ec,d/2);
                       nd=nc;
                    }
                    else c[i]-=s;
               }}
          }

          c_mul_z(iq,iq,y,d,e);
          c_sub_z(z,x,iq,d);
          
          all_zero=1;
          for(i=0;i<d;i++)
              if(z[i]!=0){all_zero=0;break;}
          
          if(all_zero)  {
             c_balance(y,d,e);
             c_set_arrays_z(ans,y,d);

             mpz_t a[d],ztemp;
             for(i=0;i<d;i++){mpz_init(a[i]);longlongtompz(a[i],ans[i]);}
             mpz_init(ztemp);
             mpf_t na,ftemp;
             mpf_init(na);
             mpf_init(ftemp);

             pol_norm_z(na,a,d,e);
             longlongtompz(ztemp,p);
             mpf_set_z(ftemp,ztemp);
             mpf_sub(ftemp,ftemp,na);
             mpf_abs(ftemp,ftemp);

             for(i=0;i<d;i++)mpz_clear(a[i]);
             mpz_clear(ztemp);
             mpf_clear(na);

             if(mpf_cmp_d(ftemp,0.4)>0)  {
               // wrong norm, find the gcd with gmp code
               mpf_clear(ftemp);
               mpz_t a[d],x3[d],y3[d];
               for(i=0;i<d;i++)mpz_init(a[i]);
               for(i=0;i<d;i++){mpz_init(x3[i]);longlongtompz(x3[i],x2[i]);}
               for(i=0;i<d;i++){mpz_init(y3[i]);longlongtompz(y3[i],y2[i]);}
             
               ret=pol_gcd(a,x3,y3,p,d,e,balanced,fiddle,gen,stat);
               for(i=0;i<d;i++)ans[i]=mpztolonglong(a[i]);
               for(i=0;i<d;i++)mpz_clear(a[i]);
               for(i=0;i<d;i++)mpz_clear(x3[i]);
               for(i=0;i<d;i++)mpz_clear(y3[i]);
               break;
             }
             mpf_clear(ftemp);

             if(stat)  {
                printf("iterations=%d\n",count_iterations);
                printf("    failed=%d\n",count_failed);
                printf("  balanced=%d\n",count_balance);
             }
             
             ret=1;
             break;
          }
          
          c_embed_z(ez,z,d,e);
          nz=c_prodnorm_f(ez,d/2);

          if(balanced)  {
             
             temp_z=0;
             for(i=0;i<d;i++){
                 if(z[i]>0)temp_z+=z[i];
                 else temp_z-=z[i];
             }
             temp=(long double)temp_z;
             
             if((long double)temp/d>10*exp((long double)log(nz)/d))  {
                count_balance++;
                c_balance(z,d,e);
                c_embed_z(ez,z,d,e);
             }
          }
          
          if(nz<ny)  {
             c_set_arrays_z(x,z,d);
             c_set_multi_arrays_f(ex,ez,d/2);
             nx=nz;
          }
          else  {
             gen=getrandom(gen);
             i=gen%len_SS;
             c_mul_z(z,y,c_SS2[i],d,e);
             all_zero=1;
             for(j=0;j<d;j++){
                 res=z[j]%NS;if(res<0)res+=NS;
                 if(res!=0)
                    {all_zero=0;break;}
             }
             if(all_zero)  {
                for(j=0;j<d;j++)
                    y[j]=z[j]/NS;
                c_embed_z(ey,y,d,e);
                ny=c_prodnorm_f(ey,d2);
             }
             else  {
                count_failed++;
                c_mul_z(x,x,c_SS[i],d,e);
                c_embed_z(ex,x,d,e);
                nx=c_prodnorm_f(ex,d2);
             }
         }
         if(count_iterations>=max_iterations_in_c)  {
            mpz_t a[d],x3[d],y3[d];
            for(i=0;i<d;i++)mpz_init(a[i]);
            for(i=0;i<d;i++){mpz_init(x3[i]);longlongtompz(x3[i],x2[i]);}
            for(i=0;i<d;i++){mpz_init(y3[i]);longlongtompz(y3[i],y2[i]);}
             
            ret=pol_gcd(a,x3,y3,p,d,e,balanced,fiddle,gen,stat);
            for(i=0;i<d;i++)ans[i]=mpztolonglong(a[i]);
            for(i=0;i<d;i++)mpz_clear(a[i]);
            for(i=0;i<d;i++)mpz_clear(x3[i]);
            for(i=0;i<d;i++)mpz_clear(y3[i]);

            return ret;
         }
         if(partial_count==max_iterations)  {
            partial_count=0;
            c_set_arrays_z(x,x2,d);
            c_set_arrays_z(y,y2,d);
            c_embed_z(ex,x,d,e);
            c_embed_z(ey,y,d,e);
            nx=c_prodnorm_f(ex,d2);
            ny=c_prodnorm_f(ey,d2);
         }
    }
    
    return ret;
}

void generator(mpz_t ans[],mpz_ptr w,int d,int e,lli p,int ty,int stat)  {
// w=e-th root of unity modulo p    
    assert(p%e==1);
    
    int test=0;
    lli hh,i,j,gen,x2[d],y2[d],a[d];
    mpz_t expo,gmp_p,h,h2,x[d],y[d];

    mpz_init(expo);
    mpz_init(gmp_p);
    mpz_init(h);
    mpz_init(h2);
    for(i=0;i<d;i++)mpz_init(x[i]);
    for(i=0;i<d;i++)mpz_init(y[i]);

    longlongtompz(gmp_p,p);
    mpz_sub_ui(expo,gmp_p,1);
    mpz_divexact_ui(expo,expo,e);

    gen=time(NULL);
    while(test==0)  {
         gen=getrandom(gen);
         hh=gen%p;
         longlongtompz(h,hh);
         mpz_powm(h,h,expo,gmp_p);
         mpz_set(h2,h);
         hh=mpztolonglong(h);
         test=(hh!=0);
         for(j=1;2*j<=e;j++){
             if(mpz_cmp_ui(h2,1)==0){test=0;break;}
             mpz_mul(h2,h2,h);
             mpz_mod(h2,h2,gmp_p);
         }
    }

    for(i=0;i<d;i++)mpz_set_ui(x[i],0);
    longlongtompz(x[0],p);
    for(i=0;i<d;i++)mpz_set_ui(y[i],(i==1));
    longlongtompz(y[0],hh);
    mpz_set(w,y[0]);
    mpz_neg(y[0],y[0]);
    
    for(i=0;i<d;i++)x2[i]=0;x2[0]=p;
    for(i=0;i<d;i++)y2[i]=(i==1);y2[0]=-hh;
    
    if(ty!=1)pol_gcd(ans,x,y,p,d,e,1,1,gen,stat);
    else     {c_pol_gcd(a,x2,y2,p,d,e,1,1,gen,stat);for(i=0;i<d;i++)longlongtompz(ans[i],a[i]);}
    
    mpz_clear(expo);
    mpz_clear(gmp_p);
    mpz_clear(h);
    mpz_clear(h2);
    for(i=0;i<d;i++)mpz_clear(x[i]);
    for(i=0;i<d;i++)mpz_clear(y[i]);
    
    return;
}

void ratio(mpz_ptr ret,lli p,int d,int e)  {
    
    assert(p%e==1);

    int c,cinv,i,j,res;
    mpz_t A,ans[d],gmp_p,gmp_p2,gmp_p3,s,temp,w,ww,www,wwpow[e],wwwpow,z;
    mpz_init(A);
    for(i=0;i<d;i++)mpz_init(ans[i]);
    mpz_init(gmp_p);
    mpz_init(gmp_p2);
    mpz_init(gmp_p3);
    mpz_init(s);
    mpz_init(temp);
    mpz_init(w);
    mpz_init(ww);
    mpz_init(www);
    for(i=0;i<e;i++)mpz_init(wwpow[i]);
    mpz_init(wwwpow);
    mpz_init(z);

    generator(ans,w,d,e,p,1,0);

    longlongtompz(gmp_p,p);
    mpz_pow_ui(gmp_p2,gmp_p,2);
    mpz_mul(gmp_p3,gmp_p2,gmp_p);

    mpz_powm(ww,w,gmp_p,gmp_p2);
    mpz_powm(www,ww,gmp_p,gmp_p3);
    
    mpz_set_ui(wwpow[0],1);
    for(i=1;i<e;i++){
        mpz_mul(wwpow[i],wwpow[i-1],ww);
        mpz_mod(wwpow[i],wwpow[i],gmp_p2);
    }

    mpz_set_ui(z,0);
    mpz_set_ui(wwwpow,1);
    for(i=0;i<d;i++)  {
        mpz_addmul(z,ans[i],wwwpow);
        mpz_mul(wwwpow,wwwpow,www);
        mpz_mod(wwwpow,wwwpow,gmp_p3);
    }
    mpz_mod(z,z,gmp_p3);
    mpz_divexact(z,z,gmp_p);

    for(c=2;c<e;c++)
       if(iigcd(c,e)==1)  {
          // c*cinv==1 mod e
          cinv=0;res=0;
          while(res!=1){cinv++;res=(cinv*c)%e;}
          mpz_set_ui(s,0);
          for(i=0;i<d;i++)
             mpz_addmul(s,ans[i],wwpow[(i*cinv)%e]);
          mpz_powm_ui(s,s,c,gmp_p2);
          mpz_mul(z,z,s);
          mpz_mod(z,z,gmp_p2);
      }

    mpz_set_ui(A,0);
    for(j=1;j<e;j++)  {
        mpz_ui_sub(s,1,wwpow[j]);
        mpz_sub_ui(temp,gmp_p,1);
        mpz_powm(s,s,temp,gmp_p2);
        mpz_sub_ui(s,s,1);
        
        mpz_ui_sub(temp,1,wwpow[e-j]);
        mpz_addmul(A,s,temp);
    }
    // 1/e==(1-p^2)/e mod p^2, here (1-p^2)/e is integer
    mpz_ui_sub(temp,1,gmp_p2);
    mpz_divexact_ui(temp,temp,e);
    mpz_mul(A,A,temp);
    mpz_mod(A,A,gmp_p2);

    mpz_add_ui(A,A,1);
    mpz_powm_ui(A,A,e,gmp_p2);
    mpz_mul(ret,z,A);
    mpz_mod(ret,ret,gmp_p2);

    mpz_clear(A);
    for(i=0;i<d;i++)mpz_clear(ans[i]);
    mpz_clear(gmp_p);
    mpz_clear(gmp_p2);
    mpz_clear(gmp_p3);
    mpz_clear(s);
    mpz_clear(temp);
    mpz_clear(w);
    mpz_clear(ww);
    mpz_clear(www);
    for(i=0;i<e;i++)mpz_clear(wwpow[i]);
    mpz_clear(wwwpow);
    mpz_clear(z);
}

void use_ratio(mpz_ptr ret,lli p,int d,int e,mpz_t X,mpz_t Y)  {

    mpz_t gmp_p,p2,temp,temp2;
    mpz_init(gmp_p);
    mpz_init(p2);
    mpz_init(temp);
    mpz_init(temp2);

    longlongtompz(p2,p);
    if(e!=2)  {
       mpz_mul_2exp(temp,p2,1);
       mpz_pow_ui(p2,p2,2);
       mpz_ui_sub(temp,1,temp);
       mpz_add(temp,temp,p2);   
       mpz_powm_ui(ret,Y,e,p2);
       mpz_mul(ret,ret,X);
       
       // check that ret^e=(x*y^e)^e==1 mod p
       longlongtompz(gmp_p,p);
       mpz_powm_ui(temp2,ret,e,gmp_p);
       assert(mpz_cmp_ui(temp2,1)==0);       
       
       mpz_powm(ret,ret,temp,p2);
       mpz_neg(ret,ret);
       mpz_mod(ret,ret,p2);
    }
    else  {
       mpz_set(temp,p2);
       mpz_pow_ui(p2,p2,2);
       mpz_set_ui(ret,2);
       mpz_powm(ret,ret,temp,p2);
       mpz_ui_sub(ret,1,ret);
       mpz_powm_ui(temp,Y,2,p2);
       mpz_mul(ret,ret,temp);
       if(p%4==1)mpz_neg(ret,ret);
       mpz_mod(ret,ret,p2);
    }
    
    mpz_clear(gmp_p);
    mpz_clear(p2);
    mpz_clear(temp);
    mpz_clear(temp2);
    return;
}

// ********************************
// end of polynomial gcd routine
// ********************************

void wilsonremainder(mpz_ptr res,mpz_t p){
// slow, no big tricks, not used, no limitation for p
// just for educational purpose
// Computation of res=(p-1)! mod p*p
    int ext=0;
    mpz_t i,p2;
    mpz_init_set_ui(i,2);
    mpz_init(p2);
    mpz_pow_ui(p2,p,2);
    mpz_set_ui(res,1);
    
    while(mpz_cmp(i,p)<0)  {
        ext++;
        mpz_mul(res,res,i);
        mpz_add_ui(i,i,1);
        if(ext==6){mpz_mod(res,res,p2);ext=0;}// reduce after every six multiplication, before reduction 0<res<p^8
    }
    mpz_mod(res,res,p2);
    
    mpz_clear(i);
    mpz_clear(p2);
    return;
}

lli wilson21(lli p)  {// slow, not used, p<2^21
   assert(p>0&&p<(1<<21));
   lli res=1,i,p2=p*p;
   for(i=2;i<p;i++)res=(res*i)%p2;// 0<res<p^3<2^63, so fits in long long int type
   return res;
}

lli factorialp(lli n,lli p)  {
// p^ret is the exact p divisor of n!
    if(n<p)return 0;
    lli ret=0;
    while(n)  {
          n/=p;
          ret+=n;
    }
    return ret;
}

void initprimes(int n)  {

    unsigned int *isprime,Bits[32];
    int i,j,si=n/32+1;
    isprime=safe_malloc(si*sizeof(unsigned int));
    for(i=0;i<si;i++)  isprime[i]=0xffffffff;
    Bits[0]=1;
    for(i=1;i<32;i++)Bits[i]=2*Bits[i-1];
    
    isprime[0]&=~Bits[0];
    isprime[0]&=~Bits[1];
    for(i=0;i*i<n;i++)
        if((isprime[i>>5]&Bits[i&31])>0)  {
           for(j=i*i;j<n;j+=i)  isprime[j>>5]&=~Bits[j&31];
        }
    
    primepi=0;
    for(i=0;i<n;i++)
        if((isprime[i>>5]&Bits[i&31])>0)  primepi++;
    prime=safe_malloc(primepi*sizeof(int));
    primepi=0;
    for(i=0;i<n;i++)
        if((isprime[i>>5]&Bits[i&31])>0)  prime[primepi++]=i;
    
    safe_free(isprime);

    return;
}

lli wheelsieve(int e,lli n1,lli n2,int numthreads)  {
// find at most 'interval' primes from [n1,n2], where p==1 mod e
    assert(n1%e==1);

    int e2,position,invtable[e];
    unsigned int Bits[32],*isprime,ui;
    lli c,ct[numthreads],ee,en,f,g,h,i,I,I2,j,J,J2,k,L,L32,mult,n32,N,num,numprimes=0,p,pos,**prim,ss,st,st2,u;

    plist=safe_malloc(interval*sizeof(lli));

    Bits[0]=1;
    for(i=1;i<32;i++)Bits[i]=2*Bits[i-1];

    position=0;
    while(allowed_even_e_values[position]!=e)position++;
    
    while(n1==1||(n1%e)!=1)n1++;
    
    for(i=0;i<e;i++)
        for(j=0;j<e;j++)
            if((i*j+1)%e==0)invtable[i]=j;
    
    for(I=n1;I<=n2&&numprimes<interval;)  {
        I2=I+interval;
        L=I2-I;
        n32=(lli)32*numthreads;
        L=n32*((L+n32-1)/n32);// L is divisible by 32*numthreads
        L32=L/32;
        u=L32/numthreads;
        
        for(i=0;i<numthreads;i++)ct[i]=0;

        isprime=safe_malloc(L32*sizeof(unsigned int));
        prim=safe_malloc(numthreads*sizeof(lli*));
                
        #pragma omp parallel for schedule(dynamic,1) private(e2,ee,en,f,g,h,j,J,J2,k,mult,num,p,ss,st,st2,ui)
        for(i=0;i<numthreads;i++)  {
            mult=(lli)e*(L/numthreads);
            J=I+i*mult;
            J2=I+(i+1)*mult;

            st=i*(L32/numthreads);
            en=(i+1)*(L32/numthreads);
    
            ss=32*st;
            ee=32*en;
            for(j=st;j<en;j++)isprime[j]=0xffffffff;
            
            for(f=0;f<primepi;f++)  {
                p=prime[f];
                if(p*p>=J2)break;                
                if(p>e||e%p>0)  {
                   // J+k*e==0 mod p
                   // k==-J/e mod p
                   k=((lli) (-J%p)*(((lli)invtable[p%e]*p+1)/e))%p;
                   if(k<0)k+=p;
                   if(J+(lli)k*e<=p)k+=p;
                   for(j=k+ss;j<ee;j+=p)isprime[j>>5]&=~Bits[j&31];
                }
             }
             
             if(test_all_primes_for_e==0)  {
               for(j=position+1;j<30;j++){//if there is a better e, then not use
                   e2=allowed_even_e_values[j];
                   for(h=0;h<e2;h++)
                       if((J+e*h)%e2==1){
                       // p=J+g*e>=treshold_for_e[j];
                       st2=imax(h,(treshold_for_e[j]-J+e-1)/e);
                       while((st2%e2)!=h)st2++;
                       for(g=ss+st2;g<ee;g+=e2)isprime[g>>5]&=~Bits[g&31];
             }}}

             p=J;
             num=0;
             for(j=0;j<u;j++)  {
                 ui=isprime[st+j];
                 for(k=0;k<32;k++)  {
                     if((ui&1)&&p<=n2)num++;
                     ui>>=1;
                     p+=e;
                 }
             }
             prim[i]=safe_malloc(num*sizeof(lli));
             p=J;
             num=0;
             for(j=0;j<u;j++)  {
                 ui=isprime[st+j];
                 for(k=0;k<32;k++)  {
                     if((ui&1)&&p<=n2){prim[i][num]=p;num++;}
                     ui>>=1;
                     p+=e;
                 }
              }
              ct[i]=num;
        }
        
        N=0;
        for(i=0;i<numthreads;i++)N+=ct[i];  
       
        if(numprimes+N<=interval)  {
           #pragma omp parallel for schedule(dynamic,1) private(c,j,pos)
           for(i=0;i<numthreads;i++)  {
              pos=numprimes;
              c=ct[i];
              for(j=0;j<i;j++)pos+=ct[j];     
              for(j=0;j<c;j++)plist[pos++]=prim[i][j];
           }
           numprimes+=N;
        }
        else  {
           for(i=0;i<numthreads&&numprimes<interval;i++)
              for(j=0;j<ct[i];j++)
                  if(numprimes<interval)plist[numprimes++]=prim[i][j];
        }
        
        I+=(lli)L*e;
        safe_free(isprime);
        for(i=0;i<numthreads;i++)safe_free(prim[i]);safe_free(prim);
   }
   if(numprimes!=0) plist=safe_realloc(plist,numprimes*sizeof(lli));
   return numprimes;
}

void setuppow1024(void)  {
    
    int i;
    mpz_t n;
    mpz_init(n);
    
    pow1024=safe_malloc(1024*62*sizeof(lli));
    for(i=0;i<1024*62;i++)  {
        mpz_set_ui(n,1);
        mpz_mul_2exp(n,n,i);
        mpz_root(n,n,1024);
        pow1024[i]=mpztolonglong(n);
    }
    mpz_clear(n);
    return;
}

void
mpn_copyi (mp_ptr rp, mp_srcptr up, mp_size_t n)
{
  mp_size_t i;

  up += n;
  rp += n;
  for (i = -n; i != 0; i++)
    rp[i] = up[i];
}

void
mpn_zero (mp_ptr rp, mp_size_t n)
{
  mp_size_t i;

  rp += n;
  for (i = -n; i != 0; i++)
    rp[i] = 0;
}

void
mpn_com (mp_ptr rp, mp_srcptr up, mp_size_t n)
{
  mp_limb_t ul;
  do {
      ul = *up++;
      *rp++ = ~ul & GMP_NUMB_MASK;
  } while (--n != 0);
}

mp_limb_t my_mpn_add_n(mp_limb_t *x3,mp_limb_t *x2,mp_limb_t *x1,mp_size_t n,int numthreads)  {
  
   if(n<1)return ZERO;
   if(enable_parallel_for_easy_func==0||TRESHOLD_FOR_EASY_PARALLEL>n||n<numthreads)return mpn_add_n(x3,x2,x1,n);

   int i;
   mp_limb_t cy[numthreads],c;

   #pragma omp parallel for schedule(dynamic,1)
   for(i=0;i<numthreads;i++){
       mp_limb_t st,en,len;
       st=(mp_limb_t)i*n/numthreads;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       len=en-st;
       cy[i]=mpn_add_n(x3+st,x2+st,x1+st,len);
   }

   c=cy[0];
   for(i=1;i<numthreads;i++){
       mp_limb_t st,en,len;
       st=(mp_limb_t)i*n/numthreads;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       len=en-st;
       c=cy[i]+mpn_add_1(x3+st,x3+st,len,c);
   }
   return c;
}    

mp_limb_t my_mpn_sub_n(mp_limb_t *x3,mp_limb_t *x2,mp_limb_t *x1,mp_size_t n,int numthreads)  {
   
    if(n<1)return ZERO;
    if(enable_parallel_for_easy_func==0||TRESHOLD_FOR_EASY_PARALLEL>n||n<numthreads)return mpn_sub_n(x3,x2,x1,n);

    int i;
    mp_limb_t cy[numthreads],c;

    #pragma omp parallel for schedule(dynamic,1)
    for(i=0;i<numthreads;i++){
       mp_limb_t st,en,len;
       st=(mp_limb_t)i*n/numthreads;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       len=en-st;
       cy[i]=mpn_sub_n(x3+st,x2+st,x1+st,len);
    }

    c=cy[0];
    for(i=1;i<numthreads;i++){
       mp_limb_t st,en,len;
       st=(mp_limb_t)i*n/numthreads;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       len=en-st;
       c=cy[i]+mpn_sub_1(x3+st,x3+st,len,c);
    }
    return c;
}    

void my_mpn_copyi(mp_limb_t *x,mp_limb_t *y,mp_size_t n,int numthreads)  {
   
    if(n<1)return;
    if(enable_parallel_for_easy_func==0||TRESHOLD_FOR_EASY_PARALLEL>n||n<numthreads){mpn_copyi(x,y,n);return;}

    int i;
    #pragma omp parallel for schedule(dynamic,1)
    for(i=0;i<numthreads;i++){
       mp_limb_t st,en,len;
       st=(mp_limb_t)i*n/numthreads;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       len=en-st;
       mpn_copyi(x+st,y+st,len);
    }
    return;
}

mp_limb_t my_mpn_rshift(mp_limb_t *x,mp_limb_t *y,mp_size_t n,int sh,int numthreads)  {
    
    assert(sh>0&&sh<GMP_LIMB_BITS);
    if(n<1)return ZERO;
    if(enable_parallel_for_easy_func==0||TRESHOLD_FOR_EASY_PARALLEL>n||n<numthreads)return mpn_rshift(x,y,n,sh);

    int i;
    mp_limb_t cy[numthreads],mask=(ONE<<sh)-ONE;

    for(i=0;i<numthreads;i++){
       mp_limb_t st;
       st=(mp_limb_t)i*n/numthreads;
       cy[i]=y[st]&mask;
    }

    #pragma omp parallel for schedule(dynamic,1)
    for(i=0;i<numthreads;i++){
       mp_limb_t st,en,len;
       st=(mp_limb_t)i*n/numthreads;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       len=en-st;
       mpn_rshift(x+st,y+st,len,sh);
       if(i!=numthreads-1)x[en-1]+=cy[i+1]<<(GMP_LIMB_BITS-sh);
    }
    return cy[0];
}

mp_limb_t my_mpn_lshift(mp_limb_t *x,mp_limb_t *y,mp_size_t n,int sh,int numthreads)  {
    
    assert(sh>0&&sh<GMP_LIMB_BITS);
    if(n<1)return ZERO;
    if(enable_parallel_for_easy_func==0||TRESHOLD_FOR_EASY_PARALLEL>n||n<numthreads)return mpn_lshift(x,y,n,sh);

    int i;
    mp_limb_t cy[numthreads];

    for(i=0;i<numthreads;i++){
       mp_limb_t en;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       cy[i]=y[en-1];
    }

    #pragma omp parallel for schedule(dynamic,1)
    for(i=0;i<numthreads;i++){
       mp_limb_t st,en,len;
       st=(mp_limb_t)i*n/numthreads;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       len=en-st;
       mpn_lshift(x+st,y+st,len,sh);
       if(i!=0)x[st]+=cy[i-1]>>(GMP_LIMB_BITS-sh);
    }
    return cy[numthreads-1];
}

void my_mpn_zero(mp_limb_t *x,mp_size_t n,int numthreads)  {
    
    if(n<1)return;
    if(enable_parallel_for_easy_func==0||TRESHOLD_FOR_EASY_PARALLEL>n||n<numthreads){return mpn_zero(x,n);return;}

    int i;
    #pragma omp parallel for schedule(dynamic,1)
    for(i=0;i<numthreads;i++){
       mp_limb_t st,en,len;
       st=(mp_limb_t)i*n/numthreads;
       en=(mp_limb_t)(i+1)*n/numthreads;
       if(en>n)en=n;
       len=en-st;
       mpn_zero(x+st,len);
    }
    return;
}

int bs(lli x)  {
    
    int pow2=32768,v=-1,v2;
    // binary search
    while(pow2){
          v2=v+pow2;
          if(v2<63488&&pow1024[v2]<x)v=v2;//1024*62=63488
          pow2>>=1;
    }
    return v+1;
}

lli get_num_limbs(lli* A,lli pos1,lli pos2){
// get an upper bound for the size of prod(i=pos1,pos2,A[i]) in limbs
// for empty product and product=1 return 1
  if(pos1>pos2)return 1;
  
  lli i,r=0,ret=0;

  for(i=pos1;i<=pos2;i++)  {
      r+=bs(A[i]);
      if(r>=65536){r-=65536;ret++;}
  }
  return imax(1,ret+(r+65535)/65536);
}

int is_it_on_tree(lli offset,lli n,int depth){
   // not time critical (though fast)
   lli pow2=1LL<<depth;
      
   for(;depth>0;depth--){
       pow2>>=1;
       if(offset>=pow2){
	 offset-=pow2;
	 n=(n+1)>>1;
       }
       else n>>=1;
   }
   
   return (n==1LL);
}

lli getpos(lli pos,lli n,int depth){
   // number of leafes of the tree up to pos
   if(pos<0)return 0;
   if(pos>=(1LL<<depth))return n;

   lli pow2=1LL<<depth,ret=0;
   if(n==pow2)return pos+1;
   
   for(;depth>0;depth--){
      pow2>>=1; 
      if(pos>=pow2){
         pos-=pow2;
         ret+=n>>1;
         n=(n+1)>>1;
      }
      else n>>=1;
   }

   return ret+n; 
}

mp_size_t prodtree(mp_limb_t *rp,lli* a,lli pos1,lli pos2,mp_limb_t* t,mp_size_t* si,mp_limb_t* temp)  {
// computation of prod(i=pos1,pos2,a[i]) with product tree
// assume that a[i]>=0
// assume that rp has enough space to store the product of a[pos1]*...*a[pos2]
// return value is the number of limbs of the product ( =1 if this product is zero )

   lli n=pos2-pos1+1,num;

   if(n<1)   {rp[0]=ONE;return 1;}
   if(n==1)  {rp[0]=(mp_limb_t)a[pos1];return 1;}
   
   int depth;
   mp_size_t d,i,pow2,ret;
   
   // first make a balanced tree for the numbers
   pow2=1,depth=0;
   while(pow2<n)pow2<<=1,depth++;

   num=0;
   for(i=0;i<pow2;i++){
       if(is_it_on_tree(i,n,depth)){t[i]=(mp_limb_t)a[pos1+num];num++;}
       else t[i]=ONE;
       si[i]=1;
   }   

   for(d=1;d!=pow2;d<<=1){
       for(i=0;i<pow2;i+=2*d){
           if(si[i]<MUL_TRESHOLD||si[i+d]<MUL_TRESHOLD){
              if(si[i]>=si[i+d])mpn_mul(temp,t+i,si[i],t+i+d,si[i+d]);
              else              mpn_mul(temp,t+i+d,si[i+d],t+i,si[i]);
              mpn_copyi(t+i,temp,si[i]+si[i+d]);
           }
           else ntt_mpn_mul_bonus(t+i,t+i,si[i],0,t+i+d,si[i+d],0,1,1);
           si[i]+=si[i+d];
           if(si[i]>1&&t[i+si[i]-1]==ZERO)si[i]--;// top limb is zero, decrease the size
       }
   }
   mpn_copyi(rp,t,si[0]);
   
   ret=si[0];

   return ret;
}

mp_size_t prodtree2(mp_limb_t *rp,lli* a,lli pos1,lli pos2,int delete_a,int numthreads)  {
// computation of prod(i=pos1,pos2,a[i]) using product tree
// assume that a[i]>=0
// assume that rp has at least get_num_limbs(a,pos1,pos2) and POWER2 extra limbs!
//                                      (if n<=POWER2 then we don't need extra limbs, just space to store the product)
// return value is the number of limbs of the product ( =1 if this product is zero)
// if delete_a!=0 then delete the whole "a" array
   
   lli n=pos2-pos1+1;
   if(n<1)   {rp[0]=ONE;if(delete_a!=0)safe_free(a);return ONE;}
   if(n==1)  {rp[0]=(mp_limb_t)a[pos1];if(delete_a!=0)safe_free(a);return ONE;}
   if(n<=POWER2){
      lli pow2=1;
      while(pow2<n)pow2<<=1;
      mp_limb_t *t=safe_malloc(pow2*numthreads*sizeof(mp_limb_t));
      mp_size_t *si=safe_malloc(pow2*numthreads*sizeof(mp_size_t));
      mp_limb_t *temp=safe_malloc(pow2*numthreads*sizeof(mp_limb_t));
      mp_size_t size=prodtree(rp,a,pos1,pos2,t,si,temp);
      safe_free(temp);
      safe_free(si);
      safe_free(t);
      if(delete_a!=0)safe_free(a);
      return size;
   }
   
   int numthreads2;
   lli d,i,en[POWER2],len[2*POWER2],pos[2*POWER2],st[POWER2];

   #pragma omp parallel for schedule(dynamic,1)
   for(i=0;i<POWER2;i++){
      st[i]=(lli)i*n/POWER2+pos1;
      en[i]=(lli)(i+1)*n/POWER2+pos1-1;
      if(i==POWER2-1)en[i]=pos2;
      len[i]=get_num_limbs(a,st[i],en[i]);
   }
   
   pos[0]=0;
   for(i=1;i<POWER2;i++)
       pos[i]=pos[i-1]+len[i-1];
   
   lli hossz,j,pow2=1,n2=n/POWER2+2,up;
   while(pow2<n2)pow2<<=1;
   hossz=(lli)pow2*numthreads;
   mp_limb_t *t=safe_malloc(hossz*sizeof(mp_limb_t));
   mp_size_t *si=safe_malloc(hossz*sizeof(mp_size_t));
   mp_limb_t *temp=safe_malloc(hossz*sizeof(mp_limb_t));

   for(i=0;i<POWER2;i+=numthreads){
       up=imin(POWER2,i+numthreads)-i;
       #pragma omp parallel for schedule(dynamic,1)
       for(j=0;j<up;j++)
           len[i+j]=prodtree(rp+pos[i+j],a,st[i+j],en[i+j],t+j*pow2,si+j*pow2,temp+j*pow2);
   }
   safe_free(temp);
   safe_free(si);
   safe_free(t);
   
   if(delete_a!=0)safe_free(a);
   
   numthreads2=numthreads;int e2=0;while(numthreads2%2==0)numthreads2>>=1,e2++;
   int threemultpower2=(numthreads2==3);
   
   if(threemultpower2&&enable_schedule_3power2)  {
     for(i=POWER2;i<2*POWER2;i++){pos[i]=pos[i-POWER2];len[i]=len[i-POWER2];}

     // for 3 cores in parallel do the 5,6,7-th multiplication on a single core
     // do parallel the 4-th mult on a single core and the 3rd mult on two cores
     // on 3 cores do the 2nd mult
     // 
     // in general for 3*2^e2 cores:
     // in parallel do the 5*2^e2..POWER2-1-th multiplications on a single core
     // do parallel the 4*2^e2 to 5*2^e2-1 on single core, from 4*2^e2-1 to 3*2^e2 on two cores
     // from 2^(e2+1) to 3*2^e2-1 each multiplication on three cores
     // do the rest in parallel at full speed
     
     int depth=0;numthreads2=POWER2;while(numthreads2%2==0)numthreads2>>=1,depth++;
     omp_set_nested(1);
     for(d=depth-1;d>=e2+2;d--){
        #pragma omp parallel for schedule(dynamic,1)
        for(i=imax(1<<d,5<<e2);i<(2<<d);i++){
            ntt_mpn_mul_bonus(rp+pos[2*i],rp+pos[2*i],len[2*i],0,rp+pos[2*i+1],len[2*i+1],0,1,1);
            pos[i]=pos[2*i];
            len[i]=len[2*i]+len[2*i+1];
            if(len[i]>1&&rp[pos[i]+len[i]-1]==ZERO)len[i]--;
        }
     }
     omp_set_nested(0);

     omp_set_nested(1);
     #pragma omp parallel for schedule(dynamic,1) private(numthreads2)
     for(i=(3<<e2);i<(5<<e2);i++){
         if(i>=(4<<e2))numthreads2=1;
         else numthreads2=2;
         ntt_mpn_mul_bonus(rp+pos[2*i],rp+pos[2*i],len[2*i],0,rp+pos[2*i+1],len[2*i+1],0,1,numthreads2);
         pos[i]=pos[2*i];
         len[i]=len[2*i]+len[2*i+1];
         if(len[i]>1&&rp[pos[i]+len[i]-1]==ZERO)len[i]--;
     }
     omp_set_nested(0);

     omp_set_nested(1);
     #pragma omp parallel for schedule(dynamic,1)
     for(i=(2<<e2);i<(3<<e2);i++){
         ntt_mpn_mul_bonus(rp+pos[2*i],rp+pos[2*i],len[2*i],0,rp+pos[2*i+1],len[2*i+1],0,1,3);
         pos[i]=pos[2*i];
         len[i]=len[2*i]+len[2*i+1];
         if(len[i]>1&&rp[pos[i]+len[i]-1]==ZERO)len[i]--;
     }
     omp_set_nested(0);

     for(d=e2;d>=0;d--)  {
         numthreads2=numthreads>>d;
	 omp_set_nested(1);
         #pragma omp parallel for schedule(dynamic,1)
         for(i=(1<<d);i<(2<<d);i++){
             ntt_mpn_mul_bonus(rp+pos[2*i],rp+pos[2*i],len[2*i],0,rp+pos[2*i+1],len[2*i+1],0,1,numthreads2);
             pos[i]=pos[2*i];
             len[i]=len[2*i]+len[2*i+1];
             if(len[i]>1&&rp[pos[i]+len[i]-1]==ZERO)len[i]--;
         }
         omp_set_nested(0);
      }
      len[0]=len[1];
   }
   else {
      for(d=1;d<POWER2;d<<=1)  {
         numthreads2=imax(1,numthreads/(POWER2/(2*d)));
	 omp_set_nested(1);
         #pragma omp parallel for schedule(dynamic,1)
         for(i=0;i<POWER2;i+=2*d){
            ntt_mpn_mul_bonus(rp+pos[i],rp+pos[i],len[i],0,rp+pos[i+d],len[i+d],0,1,numthreads2);
            len[i]+=len[i+d];
            if(len[i]>1&&rp[pos[i]+len[i]-1]==ZERO)len[i]--;// top limb is zero, decrease the size
         }
         omp_set_nested(0);
      }
   }
   
   return len[0];
}

mp_size_t shift_m(mp_limb_t *x,mp_size_t xsize,int numthreads)  {

   int cnt,sh;
     
   MPN_NORMALIZE(x,xsize);

   count_leading_zeros(cnt,x[xsize-1]);
   sh=(cnt+2)%GMP_LIMB_BITS;

   if(sh!=0)my_mpn_lshift(x,x,xsize+1,sh,numthreads);
   xsize++;
   MPN_NORMALIZE(x,xsize);

   return xsize;
}

void mpn_setup_barrett(mp_limb_t* mu,mp_limb_t* M,mp_size_t Msize,int numthreads)  {

    int cnt;
    count_leading_zeros(cnt,M[Msize-1]);
    assert(cnt==GMP_LIMB_BITS-2);
    
    my_mpn_lshift(M,M,Msize,GMP_LIMB_BITS-2,numthreads);
    mpn_invert2(mu,M,Msize,numthreads);
    // mu[Msize]=ONE;
    my_mpn_rshift(mu,mu,Msize,GMP_LIMB_BITS-3,numthreads);
    mu[Msize-1]+=(mp_limb_t)8;
    my_mpn_rshift(M,M,Msize,GMP_LIMB_BITS-2,numthreads);

    return;
}

mp_limb_t my_invert_limb(mp_limb_t a)  {

    if(a==ONE)  return MP_LIMB_T_MAX;

    mp_limb_t x[3],d[1],q[3];

    x[0]=ZERO;
    x[1]=ZERO;
    x[2]=ONE;

    d[0]=a;

    mpn_tdiv_qr(q,x,0,x,3,d,1);

    if(q[1]>ONE)  return MP_LIMB_T_MAX;
    return q[0];
}

/* Input: A = {ap, n} with most significant bit set.
   Output: X = B^n + {xp, n} where B = 2^GMP_NUMB_BITS.

   X is a lower approximation of B^(2n)/A with implicit msb.
   More precisely, one has:

              A*X < B^(2n) <= A*(X+1)

   or X = ceil(B^(2n)/A) - 1.
*/

void mpn_invert2 (mp_limb_t* xp, mp_limb_t* ap, mp_size_t n, int numthreads)
{
  if (n == 1)
    {
      /* invert_limb returns min(B-1, floor(B^2/ap[0])-B),
         which is B-1 when ap[0]=B/2, and 1 when ap[0]=B-1.
         For X=B+xp[0], we have A*X < B^2 <= A*(X+1) where
         the equality holds only when A=B/2.

         We thus have A*X < B^2 <= A*(X+1).
      */
      xp[0] = my_invert_limb (ap[0]);
    }
  else if (n == 2)
    {
      mp_limb_t tp[4], up[2], sp[2], cy;

      tp[0] = ZERO;
      xp[1]= my_invert_limb (ap[1]);
      tp[3] = mpn_mul_1 (tp + 1, ap, 2, xp[1]);
      cy = mpn_add_n (tp + 2, tp + 2, ap, 2);
      while (cy) /* Xh is too large */
        {
          xp[1] --;
          cy -= mpn_sub (tp + 1, tp + 1, 3, ap, 2);
        }
      /* tp[3] should be 111...111 */

      mpn_com (sp, tp + 1, 2);
      cy = mpn_add_1 (sp, sp, 2, ONE);
      /* cy should be 0 */

      up[1] = mpn_mul_1 (up, sp + 1, 1, xp[1]);
      cy = mpn_add_1 (up + 1, up + 1, 1, sp[1]);
      /* cy should be 0 */
      xp[0] = up[1];

      /* update tp */
      cy = mpn_addmul_1 (tp, ap, 2, xp[0]);
      cy = mpn_add_1 (tp + 2, tp + 2, 2, cy);
      do
        {
          cy = mpn_add (tp, tp, 4, ap, 2);
          if (cy == ZERO)
              mpn_add_1 (xp, xp, 2, ONE);
        }
      while (cy == ZERO);

      /* now A*X < B^4 <= A*(X+1) */
    }
  else
    {
      mp_size_t l, h;
      mp_limb_t *tp, *up;
      mp_limb_t cy, th;

      l = (n - 1) / 2;
      h = n - l;

      mpn_invert2 (xp + l, ap + l, h, numthreads);

      tp = safe_malloc((n + h)*sizeof(mp_limb_t));
      up = safe_malloc((2 * h)*sizeof(mp_limb_t));
      ntt_mpn_mul_bonus(tp,ap,n,1,xp+l,h,1,1,numthreads);// mpn_mul (tp, ap, n, xp + l, h);
      cy = my_mpn_add_n (tp + h, tp + h, ap, n, numthreads);
      while (cy)
        {
          mpn_sub_1 (xp + l, xp + l, h, ONE);
          cy -= mpn_sub (tp, tp, n + h, ap, n);
        }

      mpn_com (tp, tp, n);
      th = ~tp[n] + mpn_add_1 (tp, tp, n, ONE);
      ntt_mpn_mul_bonus(up,tp+l,h,1,xp+l,h,1,1,numthreads);// mpn_mul_n (up, tp + l, xp + l, h);
      cy = my_mpn_add_n (up + h, up + h, tp + l, h, numthreads);
      if (th != ZERO)
        cy += ONE + my_mpn_add_n (up + h, up + h, xp + l, h, numthreads);
      MPN_COPY (xp, up + 2 * h - l, l);
      mpn_add_1 (xp + l, xp + l, h, cy);
      safe_free(tp);
      safe_free(up);
    }
}

void mpn_barrett1(mp_limb_t *a0,mp_limb_t *x,mp_limb_t *mu,mp_limb_t *M,mp_size_t Msize,int numthreads){
// compute (a0)=(x%M), we delete x
// size of a0,a1,mu is Msize
// size of x is 2*Msize-1 (if size of x is smaller than 2*Msize-1, then the limbs up to 2*Msize-1 should be zero)
// assume that x/M^2 is small
// assert M is already shifted for Barrett (mu is the inverse) and Msize>1

     if(Msize<=BARRETT1_TRESHOLD)  {
        MPN_NORMALIZE(M,Msize);
        mp_limb_t *temp=safe_malloc(Msize*sizeof(mp_limb_t));
        mpn_tdiv_qr(temp,a0,0,x,2*Msize-1,M,Msize);
        safe_free(x);
        safe_free(temp);
        return;
     }

     mp_limb_t *a1,*temp;
     a1=safe_malloc(Msize*sizeof(mp_limb_t));
     my_mpn_copyi(a0,x,Msize-1,numthreads);
     a0[Msize-1]=0;
     my_mpn_copyi(a1,x+Msize-1,Msize,numthreads);
     int rr=a1[0]%32;
     safe_free(x);
     
     temp=safe_malloc(2*Msize*sizeof(mp_limb_t));
     ntt_mpn_mul_bonus(temp, a1, Msize, 0, mu, Msize, 1, 1, numthreads);
     
     my_mpn_copyi(a1,temp+Msize-1,Msize,numthreads);
     my_mpn_rshift(a1,a1,Msize,5,numthreads);
     ntt_mpn_mul_bonus(temp, a1, Msize, 1, M, Msize, 1, 1, numthreads);
     safe_free(a1);
     rr-=temp[Msize-1]%32;
     
     rr-=my_mpn_sub_n(a0,a0,temp,Msize-1,numthreads);
     safe_free(temp);
     rr%=32;if(rr<0)rr+=32;
     a0[Msize-1]=rr;

     while(mpn_cmp(a0,M,Msize)>=0)
           my_mpn_sub_n(a0,a0,M,Msize,numthreads);

     return;
}

void test_barrett1(void)  {
   
   int nt;
   lli i,iter;
   mp_size_t n;
   mp_limb_t top;
   struct timeval start,end;
   TIME_DIFF *diff;
   
   printf("Give number of limbs and number of cores and number of iterations on each line!\n");
   while(gmp_scanf("%zd%d%lld",&n,&nt,&iter)!=EOF){
        omp_set_num_threads(nt);

        mp_limb_t *M=safe_malloc((n+1)*sizeof(mp_limb_t));
        mpn_random(M,n);
        M[n]=ZERO;

        n=shift_m(M,n,nt);
        mp_limb_t *inv=safe_malloc(n*sizeof(mp_limb_t));	
        mpn_setup_barrett(inv,M,n,nt);  

        mp_limb_t *x=safe_malloc(2*n*sizeof(mp_limb_t));
        mp_limb_t *temp_x=safe_malloc(2*n*sizeof(mp_limb_t));
        mp_limb_t *y=safe_malloc(2*n*sizeof(mp_limb_t));
        mp_limb_t *a=safe_malloc(n*sizeof(mp_limb_t));
        mp_limb_t *b=safe_malloc(n*sizeof(mp_limb_t));
        mp_limb_t *temp=safe_malloc(2*n*sizeof(mp_limb_t));

        mpn_random(x,2*n);
        x[2*n-1]=ZERO;
        x[2*n-2]=ONE+(x[2*n-2]&31);
        top=x[2*n-2];
        mpn_copyi(y,x,2*n);

        mpn_copyi(temp_x,x,2*n);
        gettimeofday(&start,NULL);
        for(i=0;i<iter;i++){
          mpn_copyi(x,temp_x,2*n); 
          mpn_barrett1(a,x,inv,M,n,nt);
          x=safe_malloc(2*n*sizeof(mp_limb_t));
        }
        gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("%d threaded time (%lld iterations) of barrett1 (without precomputations)=%lf sec.\n",nt,iter,(double)diff->secs+(double)diff->usecs/1000000.);

        gettimeofday(&start,NULL);
        for(i=0;i<iter;i++)mpn_tdiv_qr(temp,b,0,y,2*n,M,n);
        gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("(single threaded) (%lld iterations) mpn_tdiv_qr=%lf sec.\n",iter,(double)diff->secs+(double)diff->usecs/1000000.);

        assert(mpn_cmp(a,b,n)==0);
        gmp_printf("Passed. [top limb of x was %lld, top limb of M was %lld, x/M^2 is approx. %lld%c%lld]\n",(lli)top,(lli)M[n-1],(lli)top,'/',(lli)M[n-1]*M[n-1]);
        safe_free(a);
        safe_free(b);
        safe_free(x);
        safe_free(y);
        safe_free(M);
        safe_free(inv);
        safe_free(temp);  
        safe_free(temp_x);
  }
  return;
}

void mpn_barrett2(mp_limb_t *a0,mp_limb_t *a1,mp_limb_t *x,mp_limb_t *mu,mp_limb_t *M,mp_size_t Msize,int numthreads){
// compute (a0,a1)=(x%M,x/M), we delete x
// size of a0,a1,mu is Msize
// size of x is 2*Msize-1
// assume that x/M^2 is small and Msize>1

     my_mpn_copyi(a0,x,Msize-1,numthreads);
     a0[Msize-1]=0;
     my_mpn_copyi(a1,x+Msize-1,Msize,numthreads);
     int rr=a1[0]%32;
     safe_free(x);
     
     mp_limb_t *temp;
     temp=safe_malloc(2*Msize*sizeof(mp_limb_t));
     ntt_mpn_mul_bonus(temp, a1, Msize, 0, mu, Msize, 1, 1, numthreads);
     
     my_mpn_copyi(a1,temp+Msize-1,Msize,numthreads);
     my_mpn_rshift(a1,a1,Msize,5,numthreads);
     ntt_mpn_mul_bonus(temp, a1, Msize, 1, M, Msize, 1, 1, numthreads);

     rr-=temp[Msize-1]%32;
     
     rr-=my_mpn_sub_n(a0,a0,temp,Msize-1,numthreads);
     rr%=32;if(rr<0)rr+=32;
     a0[Msize-1]=rr;
     
     safe_free(temp);

     while(mpn_cmp(a0,M,Msize)>=0){
           my_mpn_sub_n(a0,a0,M,Msize,numthreads);
           mpn_add_1(a1,a1,Msize,ONE);
     }

     return;
}

void mpn_barrett3(mp_limb_t *a0,mp_limb_t *a1,mp_limb_t *x,mp_limb_t *mu,mp_limb_t *M,mp_size_t Msize,int sq,int numthreads){
// compute (a1*M+a0)*x mod M^2, where 0<=a0,a1<M and 0<=x
// size of a0,a1,mu is Msize
// size of x is 2*Msize-1
// assume that x/M^2 is small and Msize>1
// we delete x
// if sq=1 then it is a squaing, so x=a1*M+a0

     // handle the easy case: a1=0 and a0*x<m
     mp_size_t a0size,a1size,xsize;
     a0size=Msize;MPN_NORMALIZE(a0,a0size);
     a1size=Msize;MPN_NORMALIZE(a1,a1size);
     if(sq!=1)  {xsize=2*Msize-1;MPN_NORMALIZE(x,xsize);}
     else       {if(a1size>0)xsize=a1size+Msize;else xsize=a0size;}
     if(a1size==0&&a0size+xsize+1<=Msize)  {
        mp_limb_t *temp=safe_malloc((a0size+xsize)*sizeof(mp_limb_t));
        if(sq!=1)  ntt_mpn_mul_bonus(temp,a0,a0size,0,x,xsize,0,1,numthreads);
        else       ntt_mpn_mul_bonus(temp,a0,a0size,0,a0,a0size,0,1,numthreads);
        my_mpn_copyi(a0,temp,a0size+xsize,numthreads);
        safe_free(temp);
        if(sq!=1)  safe_free(x);
        return;
     }

     mp_limb_t *b0,*b1,*temp,*temp2;
     b0=safe_malloc(Msize*sizeof(mp_limb_t));
     b1=safe_malloc(Msize*sizeof(mp_limb_t));

     if(sq!=1)  mpn_barrett2(b0,b1,x,mu,M,Msize,numthreads);
     else       {my_mpn_copyi(b0,a0,Msize,numthreads);my_mpn_copyi(b1,a1,Msize,numthreads);}
     
     // (a1*b0+a0*b1)%M part
     temp=safe_malloc(2*Msize*sizeof(mp_limb_t));
     ntt_mpn_mul_bonus(temp, a0, Msize, 1, b1, Msize, 0, 1, numthreads);

     safe_free(b1);
     temp2=safe_malloc(2*Msize*sizeof(mp_limb_t));
     ntt_mpn_mul_bonus(temp2, a1, Msize, 0, b0, Msize, 1, 1, numthreads);

     my_mpn_add_n(temp,temp,temp2,2*Msize,numthreads);
     safe_free(temp2);
     mpn_barrett1(a1,temp,mu,M,Msize,numthreads);
     
     // a0*b0 part
     temp=safe_malloc(2*Msize*sizeof(mp_limb_t));
     ntt_mpn_mul_bonus(temp, a0, Msize, 0, b0, Msize, 0, 1, numthreads);
     safe_free(b0);

     temp2=safe_malloc(Msize*sizeof(mp_limb_t));
     mpn_barrett2(a0,temp2,temp,mu,M,Msize,numthreads);
     my_mpn_add_n(a1,a1,temp2,Msize,numthreads);
     safe_free(temp2);
     if(mpn_cmp(a1,M,Msize)>=0)
        my_mpn_sub_n(a1,a1,M,Msize,numthreads);
     
     return;
}

void testfun(void) {
    
    int cores,sh;
    mp_size_t n;
    struct timeval start,end;
    TIME_DIFF *diff;
    
    printf("Test of (easy) parallel functions... Give number of limbs and number of cores!\n");
    while(scanf("%zd%d",&n,&cores)!=EOF)  {
          omp_set_num_threads(cores);
          mp_limb_t *x,*y,*z,*z2;
          x=safe_malloc(n*sizeof(mp_limb_t));
          y=safe_malloc(n*sizeof(mp_limb_t));
          z=safe_malloc(n*sizeof(mp_limb_t));
          z2=safe_malloc(n*sizeof(mp_limb_t));
          mpn_random(x,n);
          mpn_random(y+1,n-1);
          y[0]=rand();

          gettimeofday(&start,NULL);
          mpn_sub_n(z,x,y,n);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("single threaded time of subtraction=%lf sec.\n",(double)diff->secs+(double)diff->usecs/1000000.);
          
          gettimeofday(&start,NULL);
          my_mpn_sub_n(z2,x,y,n,cores);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("%d threads time of subtraction=%lf sec.\n",cores,(double)diff->secs+(double)diff->usecs/1000000.);
          assert(mpn_cmp(z,z2,n)==0);
          
          gettimeofday(&start,NULL);
          mpn_add_n(z,x,y,n);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("single threaded time of addition=%lf sec.\n",(double)diff->secs+(double)diff->usecs/1000000.);
          
          gettimeofday(&start,NULL);
          my_mpn_add_n(z2,x,y,n,cores);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("%d threads time of addition=%lf sec.\n",cores,(double)diff->secs+(double)diff->usecs/1000000.);
          assert(mpn_cmp(z,z2,n)==0);
          
          sh=1+rand()%(GMP_LIMB_BITS-1);
          gettimeofday(&start,NULL);
          mpn_rshift(z,x,n,sh);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("single threaded time of right shift=%lf sec.\n",(double)diff->secs+(double)diff->usecs/1000000.);
          
          gettimeofday(&start,NULL);
          my_mpn_rshift(z2,x,n,sh,cores);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("%d threads time of right shift=%lf sec.\n",cores,(double)diff->secs+(double)diff->usecs/1000000.);
          assert(mpn_cmp(z,z2,n)==0);

          sh=1+rand()%(GMP_LIMB_BITS-1);
          gettimeofday(&start,NULL);
          mpn_lshift(z,x,n,sh);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("single threaded time of left shift=%lf sec.\n",(double)diff->secs+(double)diff->usecs/1000000.);
          
          gettimeofday(&start,NULL);
          my_mpn_lshift(z2,x,n,sh,cores);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("%d threads time of left shift=%lf sec.\n",cores,(double)diff->secs+(double)diff->usecs/1000000.);
          assert(mpn_cmp(z,z2,n)==0);

          gettimeofday(&start,NULL);
          mpn_copyi(z,x,n);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("single threaded time of copy=%lf sec.\n",(double)diff->secs+(double)diff->usecs/1000000.);
          
          gettimeofday(&start,NULL);
          my_mpn_copyi(z2,x,n,cores);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("%d threads time of copy=%lf sec.\n",cores,(double)diff->secs+(double)diff->usecs/1000000.);
          assert(mpn_cmp(z,z2,n)==0);

          gettimeofday(&start,NULL);
          mpn_zero(z,n);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("single threaded time of zero=%lf sec.\n",(double)diff->secs+(double)diff->usecs/1000000.);
          
          gettimeofday(&start,NULL);
          my_mpn_zero(z2,n,cores);
          gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("%d threads time of zero=%lf sec.\n",cores,(double)diff->secs+(double)diff->usecs/1000000.);
          assert(mpn_cmp(z,z2,n)==0);

          safe_free(x);
          safe_free(y);
          safe_free(z);
          safe_free(z2);
   }
   return;
}

void write_mpn(FILE* out,mp_limb_t *x,mp_size_t size,int numthreads)  {
// output size of x (in bytes) then x to out file
    lli i,len,op=0;
    
    while(size>1&&x[size-1]==ZERO)size--;
  
    len=(lli) 8*(size-1);    
    mp_limb_t r=x[size-1];
    while(r!=ZERO){len++;r>>=8;}    
    if(len<=0)len=1;
    
    fprintf(out,"%lld ",len);

    char *w=safe_malloc((OUT_SIZE+1)*sizeof(char));
    for(i=len-1;i>=0;i--){
        r=(x[i>>3]>>((i&7)<<3))&255;
        w[op++]=(char)r;
	if(op==OUT_SIZE){fwrite(w,sizeof(char),op,out);op=0;}
    }    
    if(op>0)fwrite(w,sizeof(char),op,out);  
    fprintf(out,"\n");

    safe_free(w);
    return;
}

void read_mpn(FILE* in,mp_limb_t *x,lli len,int numthreads)  {
// read from in file len bytes of number to x (assume that we need to read a (space) character also)
    char *w=safe_malloc((len+1)*sizeof(char));
    
    fread(w,sizeof(char),1,in);
    fread(w,sizeof(char),len,in);
    
    int r;
    lli i,pos,si=(len+7)/8;
    mp_limb_t n;

    my_mpn_zero(x,si,numthreads);
    
    #pragma omp parallel for schedule(dynamic,65536) private(n,pos,r) // chunk should be divisible by 8
    for(i=len-1;i>=0;i--){
        pos=len-1-i;
        r=(int)w[i]; 
        if(r<0)r+=256;
        n=(mp_limb_t)r;
        x[pos>>3]+=n<<((pos&7)<<3);
    }
    safe_free(w);
    
    return;
}

mp_limb_t *Q;
time_t time1,time2,time3;
time_t printingtime;

mp_size_t ff(mp_limb_t* m,mp_size_t Msize,lli n,int stage1_depth,lli stage1_q,int numthreads)  {
    // Computation of Q=n! mod m^2
    int d,depth,ind,spec;
    lli e,en,i,I,I2,j,J,J2,k,L,L64,lastprime,maxnumprimes,N,nn,n64,num,numprimes,p,pos,s,st,stI,u,up;
    lli cnt,ct[numthreads],numlimbs,*pr,*primelist;
    unsigned int Bits[32],ui,*isprime;
    double dtime;
    mp_limb_t *inv,*a0,*a1,*prod,carry;
    char name[100];
    FILE *in;
    struct timeval start,end;
    TIME_DIFF *diff;

    MPN_NORMALIZE(m,Msize);
    Msize=shift_m(m,Msize,numthreads);
    inv=safe_malloc(Msize*sizeof(mp_limb_t));
    mpn_setup_barrett(inv,m,Msize,numthreads);

    a0=safe_malloc(Msize*sizeof(mp_limb_t));
    a1=safe_malloc(Msize*sizeof(mp_limb_t));
    my_mpn_zero(a0,Msize,numthreads);a0[0]=ONE;
    my_mpn_zero(a1,Msize,numthreads);
    
    Bits[0]=1;
    for(i=1;i<32;i++)Bits[i]=2*Bits[i-1];

    depth=0;nn=n;
    while(nn>=1)  depth++,nn>>=1;

    maxnumprimes=5*interval/2;
    primelist=safe_malloc(maxnumprimes*sizeof(lli));
    
    if(stage1_depth==-1){spec=0;stage1_depth=depth;stI=0;}
    else {
       spec=1;
       a0[0]=ZERO;
       mp_size_t size;
       stI=stage1_q;
       sprintf(name,"parallelwilsontemp%d.txt",stage1_f1);
       in=fopen(name,"rb");
       gettimeofday(&start,NULL);
       gmp_fscanf(in,"%zd",&size);read_mpn(in,a1,(lli)size,numthreads);
       gmp_fscanf(in,"%zd",&size);read_mpn(in,a0,(lli)size,numthreads);
       gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
       printf(" [input time=%lf sec. (Wall)]\n",(double)diff->secs+(double)diff->usecs/1000000.);
       fclose(in);
    }
    
    time_t ido=time(NULL);
    time1=0;
    for(d=stage1_depth;d>=0;d--)  {
    // n/(p-1)>=factorialp(n,p)>=2^d
    // n/(2^d)+1>=p
    up=1+(n>>d);
    
    if(!spec)  {
       safe_free(primelist);
       mpn_barrett3(a0,a1,prod,inv,m,Msize,1,numthreads);//it is a squaring
       primelist=safe_malloc(maxnumprimes*sizeof(lli));

       // handle p=2
       if((factorialp(n,2)>>d)&1)  {
          carry=my_mpn_lshift(a0,a0,Msize,1,numthreads);
          carry=my_mpn_lshift(a1,a1,Msize,1,numthreads);
          if(mpn_cmp(a0,m,Msize)>=0)  {
             carry=my_mpn_sub_n(a0,a0,m,Msize,numthreads);
             carry=mpn_add_1(a1,a1,Msize,ONE);
          }
          if(mpn_cmp(a1,m,Msize)>=0)
             carry=my_mpn_sub_n(a1,a1,m,Msize,numthreads);
       }
    }
    spec=0;

    numprimes=0;
    numlimbs=0;
    ind=0;
    for(I=stI;I<=up;)  {// I should be even
        I2=imin(up+1,I+interval);
        
        L=I2-I;
	n64=(lli)64*numthreads;
        L=n64*((L+n64-1)/n64);// L is divisible by 64*numthreads
        I2=I+L;
        L64=L/64;
        u=L64/numthreads;
        
        for(i=0;i<numthreads;i++)ct[i]=0;
        
        isprime=safe_malloc(L64*sizeof(unsigned int));
                
        #pragma omp parallel for schedule(dynamic,1) private(e,en,j,J,J2,k,num,p,s,st,ui)
        for(i=0;i<numthreads;i++)  {
            J=I+i*(L/numthreads);
            J2=I+(i+1)*(L/numthreads);

            en=(J2-I)/2;
            
            s=i*(L64/numthreads);
            e=(i+1)*(L64/numthreads);
            for(j=s;j<e;j++)isprime[j]=0xffffffff;
            if(I==0&&i==0)isprime[0]&=~Bits[0];
            
            for(j=1;j<primepi;j++)  {
                p=prime[j];
                if(p*p>=J2)break;
                
                st=((J+p-1)/p)*p;
                if((st&1)==0)st+=p;
                if(st==p)st=3*p;
                
                for(k=(st-I-1)>>1;k<en;k+=p)isprime[k>>5]&=~Bits[k&31];
           }
           
           p=J+1;
           num=0;
           for(j=0;j<u;j++)  {
               ui=isprime[s+j];
               for(k=0;k<32;k++)  {
		   if(ui&1){
		     if((factorialp(n,p)>>d)&1)num++;
		     else isprime[s+j]&=~Bits[k];
		   }
                   ui>>=1;
		   p+=2;
               }
           }
           ct[i]=num;
        }
        
        N=0;
        for(i=0;i<numthreads;i++)N+=ct[i];  
        pr=safe_malloc(N*sizeof(lli));
        
        #pragma omp parallel for schedule(dynamic,1) private(j,J,k,p,pos,s,ui)
        for(i=0;i<numthreads;i++)  {
            pos=0;
            for(j=0;j<i;j++)pos+=ct[j];
	    J=I+i*(L/numthreads);
	    p=J+1;
	    s=i*(L64/numthreads);
            for(j=0;j<u;j++)  {
               ui=isprime[s+j];
               for(k=0;k<32;k++)  {
                   if(ui&1)pr[pos++]=p;
                   ui>>=1;
                   p+=2;
               }
           }
        }
        safe_free(isprime);

        if(numprimes+N<maxnumprimes&&numlimbs+N<2*Msize-3)  {
           lli lv[numthreads];
           #pragma omp parallel for schedule(dynamic,1) private(cnt,e,ind,j,s)
           for(i=0;i<numthreads;i++)  {
               s=i*(N/numthreads);
               e=(i+1)*(N/numthreads);
               if(i==numthreads-1)e=N;
               lv[i]=1;
  
               if(s<e){
                  ind=bs(pr[s]);
                  cnt=0;
                  for(j=s;j<e;j++){
                      while(pow1024[ind]<pr[j])ind++;
                      cnt+=ind;
                      if(cnt>=65536)lv[i]++,cnt-=65536;
                      primelist[numprimes+j]=pr[j];
                   }
               }

          }
          for(i=0;i<numthreads;i++)numlimbs+=lv[i];
          numprimes+=N;
        }
        else if(N>0) {
        ind=bs(pr[0]);
        cnt=0;
        numlimbs++;
        for(i=0;i<N;i++)  {
            while(pow1024[ind]<pr[i])ind++;
            cnt+=ind;
            if(cnt>=65536)numlimbs++,cnt-=65536;
            primelist[numprimes++]=pr[i];
            
            if(numprimes==maxnumprimes||numlimbs>=2*Msize-3)  {
              lastprime=primelist[numprimes-1];
              prod=safe_malloc((2*Msize+POWER2)*sizeof(mp_limb_t));
              mp_size_t size=prodtree2(prod,primelist,0,numprimes-1,1,numthreads);
              my_mpn_zero(prod+size,2*Msize-size,numthreads);
              mpn_barrett3(a0,a1,prod,inv,m,Msize,0,numthreads);
	      ido=time(NULL)-ido;if(ido>time1)time1=ido;
	      time_t guess=2*(time1+printingtime)+time(NULL)-start_time+extra_time;
              if(save_res&&(time(NULL)-time_of_last_save>=seconds_per_save||guess>=max_wall_time))
                 {gettimeofday(&start,NULL);
                   save_stage1(d,lastprime+1,a1,a0,Msize,numthreads);time_of_last_save=time(NULL);
                   gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
		   dtime=(double)diff->secs+(double)diff->usecs/1000000.;
                   printf(" [output time=%lf sec. (Wall)]\n",dtime);
		   if((time_t)dtime>printingtime)printingtime=(time_t)dtime;
		   if(guess>=max_wall_time)check_time();
                 }
              primelist=safe_malloc(maxnumprimes*sizeof(lli));
              numprimes=0;
              numlimbs=1;
	      ido=time(NULL);
           }
        }}

        I=I2;
        if(I>n/I)  {
           // I2>=I and ((n/I2)>>d) is odd
           // n/I2<cnt<<d
           // I2>n/(cnt<<d))
           if(((n/I)>>d)%2==0){cnt=(n/I)>>d;if(cnt>0)I2=n/(cnt<<d);else I2=n+2;if(I2%2==1)I2--;I=imax(I2,I);}
        }

        safe_free(pr);
    }
    if(numprimes>0)  {
       lastprime=primelist[numprimes-1];
       prod=safe_malloc((2*Msize+POWER2)*sizeof(mp_limb_t));
       mp_size_t size=prodtree2(prod,primelist,0,numprimes-1,1,numthreads);
       my_mpn_zero(prod+size,2*Msize-size,numthreads);
       mpn_barrett3(a0,a1,prod,inv,m,Msize,0,numthreads);
       ido=time(NULL)-ido;if(ido>time1)time1=ido;
       time_t guess=2*(time1+printingtime)+time(NULL)-start_time+extra_time;
       if(save_res&&(time(NULL)-time_of_last_save>=seconds_per_save||guess>=max_wall_time))
          {gettimeofday(&start,NULL);
            save_stage1(d,lastprime+1,a1,a0,Msize,numthreads);time_of_last_save=time(NULL);
            gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
	    dtime=(double)diff->secs+(double)diff->usecs/1000000.;
            printf(" [output time=%lf sec. (Wall)]\n",dtime);
	    if((time_t)dtime>printingtime)printingtime=(time_t)dtime;
	    if(guess>=max_wall_time)check_time();
           }
       primelist=safe_malloc(maxnumprimes*sizeof(lli));
       numprimes=0;
       numlimbs=0;
       ido=time(NULL);
    }
    stI=0;
    }

    safe_free(primelist);
    safe_free(inv);

    mp_size_t size=2*Msize;
    Q=safe_malloc(size*sizeof(mp_limb_t));
    ntt_mpn_mul_bonus(Q,a1,Msize,0,m,Msize,0,1,numthreads);
    carry=my_mpn_add_n(Q,Q,a0,Msize,numthreads);
    if(carry)
       carry=mpn_add_1(Q+Msize,Q+Msize,Msize,ONE);
    MPN_NORMALIZE(Q,size);
    
    safe_free(a0);
    safe_free(a1);
    safe_free(m);
    
    return size;
}



void find_opt_bounds(void)  {

    int e,e2,i,j,k;
    lli guess[30];
    guess[0]=3;

    // ee and pp should be the same for all runs, use all cores for each run.
    double ee=2;
    double pp=1e12;

    int num_pc[num_type]={5}; // number of computers of each type

    // 24822 sec for e=2 at p~1e12 with interval=2e8 on 12 cores (only the first stage), assume that we could use here the maximal iinterval2=1e9 instead of 2e8.
    // some of these are in fact integers, store in double to avoid type conversion
    double dtime[num_type]={24882.0};
    double icores[num_type]={12}; // number of cores for each type of computer
    double iinterval[num_type]={2e8}; // the interval for each run, actually not used
    double iinterval2[num_type]={1e9}; // the largest interval that we can run on the i-th type of computer
    double gcd_times_for_e[num_type][30]={ // here it is possible to use non-integer values also
      {4.,34.,43.,65.,74.,81.,110.,151.,125.,164.,220.,180.,301.,307.,204.,561.,566.,337.,789.,573.,364.,1104.,603.,1080.,817.,647.,1136.,2245.,2196.,2156.}
      };// times in microsecond per each prime near 1e13 for each even e value on the computers (using a single core)

    // you can process one prime in average ri=(ee/e)*(p/pp)*dtime/iinterval2+(gcd_times_for_e[]*1e-6)/icores (Wall time in seconds)
    // hence on all computers in T (Wall) time process t=sum(T/ri*num_pc)=T*sum(num_pc/ri) primes

    double p,ratio,ratio2,t1,t2,r1,r2,pow2;

    for(i=1;i<30;i++)  {
        e=allowed_even_e_values[i];
        for(j=0;j<i;j++)  {
           e2=allowed_even_e_values[j];
           if(e%e2==0)  {// for j=0 this holds, since e%2==0

              // find the optimal ratio=p/pp by binary search
              ratio=0.0;
	      for(pow2=1e7;pow2>1e-9;pow2*=0.5){
		  ratio2=ratio+pow2;
		  t1=0.0;
		  t2=0.0;
                  for(k=0;k<num_type;k++)  {
		     r1=(double)ee/e*ratio2*dtime[k]/iinterval2[k]+(gcd_times_for_e[k][i]*1e-6)/icores[k];
		     r2=(double)ee/e2*ratio2*dtime[k]/iinterval2[k]+(gcd_times_for_e[k][j]*1e-6)/icores[k];

		     t1+=(double)num_pc[k]/r1;
		     t2+=(double)num_pc[k]/r2;
		  }

		  if(t1<t2)ratio=ratio2;
	      }

	      // ratio=p/pp
	      p=pp*ratio;

	      if(p<(double)guess[j])p=(double)guess[j];
              if(j==0||p>(double)guess[i])guess[i]=(lli)p;
          }
      }
   }
   for(i=0;i<30;i++)printf("treshold for e=%d is p=%lld\n",allowed_even_e_values[i],guess[i]);
   printf("The output in array format:\n");
   for(i=0;i<30;i++)printf("%lldLL,\n",guess[i]);
   return;
}
/*
void find_opt_bounds(void)  {
    int e,e2,i,j;
    lli guess[30];
    guess[0]=3;
    double dd,d1,d2,p;

    // 24822 sec. for e=2 at p~1e12 with interval=2e8 on 12 cores (only the first stage)
    double dtime=24882.0;
    // some of these are in fact integers, store in double to avoid type conversion
    double ee=2;
    double pp=1e12;
    double icores=12;
    double iinterval=2e8;
    double iinterval2=iinterval;
    double gcd_times_for_e[30]={4.,34.,43.,65.,74.,81.,110.,151.,125.,164.,220.,180.,301.,307.,
    204.,561.,566.,337.,789.,573.,364.,1104.,603.,1080.,817.,647.,1136.,2245.,2196.,2156.};
    // times in microsecond per each prime near 1e13 for each even e value on my computer on a single core

    for(i=1;i<30;i++)  {
        e=allowed_even_e_values[i];
        for(j=0;j<i;j++)  {
           e2=allowed_even_e_values[j];
           if(e%e2==0)  {// for j=0 this holds, since e%2==0

              // on one core with e=1 the average time of factorial part would be: dd=dtime*icores*ee/iinterval
              //    hence  for p, e, iinterval2 this is: c1=(p/pp)/e*(iinterval/iinterval2)*dd
              // with polynomial gcd the average time is c1+gcd_times_for_e[i]*1e-6
              // so if c1+gcd_times_for_e[i]*1e-6>c2+gcd_times_for_e[j]*1e-6 and p>guess[j], then it is better to use e2 instead of e
              dd=dtime*icores*ee/iinterval;
              d1=(double)1/e*(iinterval/iinterval2)*dd/pp;
              d2=(double)1/e2*(iinterval/iinterval2)*dd/pp;
              p=1./(d1-d2)*(gcd_times_for_e[j]-gcd_times_for_e[i])*1e-6;
              if(p<(double)guess[j])p=(double)guess[j];
              if(j==0||p>(double)guess[i])guess[i]=(lli)p;
          }
      }
   }
   for(i=0;i<30;i++)printf("treshold for e=%d is p=%lld (polgcd time is %lf sec. per prime)\n",allowed_even_e_values[i],guess[i],gcd_times_for_e[i]*1e-6);
   printf("The output in array format:\n");
   for(i=0;i<30;i++)printf("%lldLL,\n",guess[i]);
   return;
}*/

void timings_of_pol_gcd(void)  {
    
    int ct,i,I,e,euler_e,numtest=50000;
    lli pp;
    mpz_t A[numtest],p,x,y,r,temp;
    for(i=0;i<numtest;i++)mpz_init(A[i]);
    mpz_init(p);
    mpz_init(x);
    mpz_init(y);
    mpz_init(r);
    mpz_init(temp);
    
    printf("%d tests for each (even) e value\n",numtest);
    for(I=0;I<30;I++)  {
       e=allowed_even_e_values[I];
       euler_e=eulerphi(e);
       init_tables(euler_e,e);

       mpz_ui_pow_ui(p,10,13);
       ct=0;
       while(ct<numtest)  {
            mpz_add_ui(p,p,1);
            mpz_nextprime(p,p);
            if(mpz_fdiv_r_ui(temp,p,e)==1)
               {mpz_set(A[ct],p);ct++;}
       
       }

       struct timeval start, end;
       TIME_DIFF *diff;
       gettimeofday(&start, NULL);
       for(i=0;i<numtest;i++)  {
           pp=mpztolonglong(A[i]);
           mpz_random(y,3);// here not computed ((pp-1)/e)! mod pp^2, this is fake residue
                           // we test only the speed of the polynomial gcd code
           if(e!=2)ratio(x,pp,euler_e,e);
           use_ratio(r,pp,euler_e,e,x,y);// if e=2, then here the X value is not used.
       }
       
       gettimeofday(&end, NULL);
       diff = my_difftime(&start, &end);
       double dd=(double)diff->secs +(double) diff->usecs/1000000.;
       printf("e=%d: average time=%.6lf sec.\n",e,(double) dd/numtest);fflush(stdout);
    }
    
    for(i=0;i<numtest;i++)mpz_clear(A[i]);
    mpz_clear(p);
    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(r);
    mpz_clear(temp);
    
    return;
}

mp_limb_t **res,**res2,*RES;
lli *len,*len2;

void write_mpn_array(FILE* out,lli l,int ty,int numthreads)  {
// output l numbers from array to out file
// if ty=0 then this array is res, for ty=1 this is res2, for ty=2 it is RES
    char *w,digit[32];
    lli hossz,h,h2,i,j,op=0,numbytes2;
    mp_limb_t r;
    mp_ptr fp;
    
    w=safe_malloc((OUT_SIZE+1)*sizeof(char));
    
    for(i=0;i<l;i++){
        if(ty==0)h=len[i],fp=res[i];
        else if(ty==1)h=len2[i],fp=res2[i];
        else h=2,fp=RES+2*i;
        while(h>1&&fp[h-1]==ZERO)h--;
 
        numbytes2=8*(h-1);
        r=fp[h-1];
        while(r!=ZERO)numbytes2++,r>>=8;
        if(numbytes2<=0)numbytes2=1;

        hossz=0;h2=numbytes2;
        while(h2>0||hossz==0)digit[hossz++]=(h2%10)+'0',h2/=10;
        for(j=hossz-1;j>=0;j--){w[op++]=digit[j];if(op==OUT_SIZE){fwrite(w,sizeof(char),op,out);op=0;}}
        w[op++]=' ';
        if(op==OUT_SIZE){fwrite(w,sizeof(char),op,out);op=0;}

        for(j=numbytes2-1;j>=0;j--)  {
            r=(fp[j>>3]>>((j&7)<<3))&255;
            w[op++]=(char)r;
            if(op==OUT_SIZE){fwrite(w,sizeof(char),op,out);op=0;}
        }
        w[op++]='\n';
        if(op==OUT_SIZE){fwrite(w,sizeof(char),op,out);op=0;}
    }
    if(op!=0)fwrite(w,sizeof(char),op,out);  
    safe_free(w);

    return;
}

void read_mpn_array(FILE* in,lli l,int ty,int numthreads)  {
// read from in file to array l numbers
// if ty=0 then this array is res, for ty=1 this is res2, for ty=2 it is RES    

    int r;
    char *w;
    lli hossz,h,i,j,op=0,pos;
    mp_size_t size;
    mp_limb_t n;
    mp_ptr fp;
    
    fseek(in,0,SEEK_END);
    hossz=(lli) ftell(in)*sizeof(char);
    rewind(in);    
    w=safe_malloc(hossz);
    fread(w,sizeof(char),hossz,in);
    
    for(i=0;i<l;i++){
        h=0;
        while(w[op]!=' ')h=10*h+(w[op]-'0'),op++;
        op++;// skip space character
        size=imax(1,(h+7)/8);

        if(ty==0){len[i]=size;res[i]=safe_malloc(len[i]*sizeof(mp_limb_t));fp=res[i];}
        else if(ty==1){len2[i]=size;res2[i]=safe_malloc(len2[i]*sizeof(mp_limb_t));fp=res2[i];}
        else {fp=RES+2*i;RES[2*i]=ZERO;RES[2*i+1]=ZERO;}

        for(j=0;j<size;j++)fp[j]=ZERO;
        for(j=h-1;j>=0;j--){
            pos=h-1-j;
            r=(int)w[op+j]; 
            if(r<0)r+=256;
            n=(mp_limb_t)r;
            fp[pos>>3]+=n<<((pos&7)<<3);
        }
        op+=h;
        op++;// skip new line character
    }
    safe_free(w);

    return;
}

mp_size_t longdivision(mp_limb_t *x,mp_size_t xsize,mp_limb_t *inv,mp_limb_t *M,mp_size_t Msize,mp_ptr fp,int numthreads){
// compute x%M with Barrett
// return value is the number of limbs of the result
// assume that M is shifted for Barrett1
// put the result at fp
     MPN_NORMALIZE(x,xsize);
     MPN_NORMALIZE(M,Msize);
     
     if(xsize<Msize){
        my_mpn_copyi(fp,x,xsize,numthreads);
        return xsize;
     }
     
     if(Msize<=2||Msize<=BARRETT1_TRESHOLD)  {
        mp_limb_t *t=safe_malloc((xsize-Msize+1)*sizeof(mp_limb_t));
        mpn_tdiv_qr(t,fp,0,x,xsize,M,Msize);
        safe_free(t);
        MPN_NORMALIZE(fp,Msize);
        return Msize;
     }
     
     mp_limb_t *temp=safe_malloc(2*Msize*sizeof(mp_limb_t));
     lli i,ct=(xsize+(Msize-2)-1)/(Msize-2),si=xsize%(Msize-2),size;
     if(si==0)si=Msize-2;
     
     my_mpn_zero(temp,2*Msize,numthreads);
     my_mpn_copyi(temp+Msize-2,x+(ct-1)*(Msize-2),si,numthreads);     
     for(i=ct-2;i>=0;i--)  {
         my_mpn_copyi(temp,x+i*(Msize-2),Msize-2,numthreads);
         mpn_barrett1(fp,temp,inv,M,Msize,numthreads);
         temp=safe_malloc(2*Msize*sizeof(mp_limb_t));
         my_mpn_zero(temp,2*Msize,numthreads);
         my_mpn_copyi(temp+Msize-2,fp,Msize,numthreads);
     }
     my_mpn_copyi(fp,temp+Msize-2,Msize,numthreads);
     size=Msize;
     MPN_NORMALIZE(fp,size);
     safe_free(temp);
       
     return size;  
}

void test_longdivision(void)  {
   
   int nt;
   lli i,iter;
   mp_size_t n,xsize;
   struct timeval start,end;
   TIME_DIFF *diff;
   
   printf("Give the number of limbs of dividend, the divisor and number of cores and number of iterations on each line!\n");
   while(gmp_scanf("%zd%zd%d%lld",&xsize,&n,&nt,&iter)!=EOF){
        omp_set_num_threads(nt);

        mp_limb_t *M=safe_malloc((n+1)*sizeof(mp_limb_t));
        mpn_random(M,n);
        M[n]=ZERO;

        n=shift_m(M,n,nt);
        mp_limb_t *inv=safe_malloc(n*sizeof(mp_limb_t));	
        mpn_setup_barrett(inv,M,n,nt);  

        mp_limb_t *x=safe_malloc(xsize*sizeof(mp_limb_t));
        mp_limb_t *r1=safe_malloc(n*sizeof(mp_limb_t));
        mp_limb_t *r2=safe_malloc(n*sizeof(mp_limb_t));
        mp_limb_t *temp=safe_malloc((xsize-n+1)*sizeof(mp_limb_t));

        mpn_random(x,xsize);

        gettimeofday(&start,NULL);
        for(i=0;i<iter;i++)longdivision(x,xsize,inv,M,n,r1,nt);
        gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("%d threaded time (%lld iterations) of longdivision (without precomputations)=%lf sec.\n",nt,iter,(double)diff->secs+(double)diff->usecs/1000000.);

        gettimeofday(&start,NULL);
        for(i=0;i<iter;i++)mpn_tdiv_qr(temp,r2,0,x,xsize,M,n);
        gettimeofday(&end,NULL);diff=my_difftime(&start,&end);printf("(single threaded) (%lld iterations) mpn_tdiv_qr=%lf sec.\n",iter,(double)diff->secs+(double)diff->usecs/1000000.);

        assert(mpn_cmp(r1,r2,n)==0);
        gmp_printf("Passed.\n");

        safe_free(x);
        safe_free(M);
        safe_free(inv);
        safe_free(temp);
        safe_free(r2);
        safe_free(r1);
  }
  return;
}

void ss(lli off,mp_limb_t *x,mp_size_t xsize,lli p)  {
// compute x%(p^2), put the result at RES+2*off
   mp_limb_t *temp=safe_malloc((xsize+1)*sizeof(mp_limb_t));
   mp_limb_t *q=safe_malloc(2*sizeof(mp_limb_t));
   mp_size_t qsize=2;
   
   temp[0]=(mp_limb_t)p;
   mpn_sqr(q,temp,1);
   MPN_NORMALIZE(x,xsize);
   MPN_NORMALIZE(q,qsize);
   
   mpn_zero(RES+2*off,2);

   if(xsize>=qsize)mpn_tdiv_qr(temp,RES+2*off,0,x,xsize,q,qsize);
   else mpn_copyi(RES+2*off,x,xsize);
   
   safe_free(temp);
   safe_free(q);
   
   return;
}  

unsigned int *diffp;
lli *firstp;
lli getpr(lli pos,int e)  {
  
  if(pos<=0)return firstp[0];
  
  unsigned int ui;
  lli i,ret=firstp[pos>>5];
  
  for(i=(pos/32)*32+1;i<=pos;i++){
      ui=(diffp[i>>1]>>(16*(i&1)))&65535;
      ret+=(lli)e*ui;
  }
  return ret;
}

void reconstruct(lli *v,lli pos1,lli pos2,int e)  {
   
   unsigned int ui;
   lli i;
   
   v[0]=getpr(pos1,e);   
   for(i=pos1+1;i<=pos2;i++){
       ui=(diffp[i>>1]>>(16*(i&1)))&65535;
       v[i-pos1]=v[i-pos1-1]+(lli)e*ui;
   }
   return;
}
time_t mod_time;
int Depth;
void fun1(lli stage2_offset,lli stage2_k,lli i,lli i2,lli numprimes,int d,int d2,int e,int lo,lli si,lli si2,int nt)  {
// 'a' is the array of primes, nt is the number of threads working here.
// We know res[t]=((a[t*2^d]-1)/e)! mod prod(h=t*2^d,u,a[h])^2, where u=imin(numprimes-1,(t+1)*2^d-1)
// res2[] is the same but for d2 instead of d
// this routine computes res2[t*2^(d-d2)],...,res2[(t+1)*2^(d-d2)-1], where t=i/2^d
// simply calculate res2[] with product tree and Barrett:
// res2[t*2^(d-d2)+j]=(res[t]*((a[s2]-1)/e)!/(a[s1]-1)/e)!) mod m^2, where s1=t*2^d and s2=t*2^d+j*2^d2 and m=prod(h=t*2^d+j*2^d2,t*2^d+(j+1)*2^d2-1,a[h])
// this is a memory efficient version of fun2, used only on the top of the tree, so d=depth (and i=0), called only once.
// here lo=0, every threads are working here

   int spec;
   lli i3,i4,i5,i6,j,k,k2,offset,start_k,pos,off,pow2,ppow2,m,n,t3,t4,t6,cnt,hi,*v;
   mp_size_t size,size4,l2;
   double dtime;
   struct timeval start,end;
   TIME_DIFF *diff;

   n=1LL<<Depth;

   if(stage2_offset==-1){spec=0;offset=0;}
   else {spec=1;offset=stage2_offset;}
   
       pow2=1LL<<d;
       ppow2=1LL<<(d-d2);
       
       pos=i/pow2;
       time_t guess,ido=time(NULL);
       time2=0;
       for(j=offset;j<ppow2;j++)  {
           i3=i+(j<<d2);
           i4=imin(n-1,i3+(1LL<<d2)-1);
           if(i3<=i4){              
              t3=getpos(i3-1,numprimes,Depth);
              t4=getpos(i4,numprimes,Depth)-1;
              if(t3<=t4){
              v=safe_malloc((t4-t3+1)*sizeof(lli));
              reconstruct(v,t3,t4,e);
              m=get_num_limbs(v,0,t4-t3);
              size=2*m+1+POWER2*(t4-t3+1>POWER2);
              mp_limb_t *temp4=safe_malloc(size*sizeof(mp_limb_t));
              size4=prodtree2(temp4,v,0,t4-t3,1,nt);
              ntt_mpn_mul_bonus(temp4,temp4,size4,0,temp4,size4,0,1,nt);
              size4*=2;
              if(temp4[size4-1]==ZERO)size4--;
              temp4[size4]=ZERO;
              size4=shift_m(temp4,size4,nt);
              mp_limb_t *inv2=safe_malloc(size4*sizeof(mp_limb_t));
              mpn_setup_barrett(inv2,temp4,size4,nt);  
  
              if(d2!=0)  off=(pos<<(d-d2))+j;
              else       off=getpos((pos<<(d-d2))+j-1,numprimes,Depth);
      
              mp_limb_t *rx;
              mp_ptr fp;
              if(d2!=0)  {
                 res2[off]=safe_malloc(size4*sizeof(mp_limb_t));
                 fp=res2[off];
                 len2[off]=longdivision(res[pos],len[pos],inv2,temp4,size4,fp,nt);
                 l2=len2[off];
              }
              else {
                 rx=safe_malloc(size4*sizeof(mp_limb_t));
                 fp=rx;
                 l2=longdivision(res[pos],len[pos],inv2,temp4,size4,fp,nt);
                 ss(off,rx,l2,getpr(off,e));
              }
  
              if(j!=0)  {
                 i5=i+((j-1)<<d2);
                 i6=i5+(1LL<<d2);
                 // t5=getpos(i5,numprimes,Depth)-1;
                 t6=getpos(i6,numprimes,Depth)-1;
                 if(spec&&j==offset){l2=read_stage2_res(fp,size4,nt);start_k=stage2_k;}
                 else {start_k=(getpr(0,e)-1)/e+1;}
                 hi=(getpr(t6,e)-1)/e;
                 for(k=start_k;k<=hi;){
                     k2=imin(hi,k+2*(t4-t3+1)-1);
                     l2=mpn_parallel_modproduct_tree(fp,l2,temp4,size4,inv2,k,k2,nt);
                     k=k2+1;
		     
		     ido=time(NULL)-ido;if(time2<ido)time2=ido;mod_time=time2;
		     guess=2*(time2+printingtime)+time(NULL)-start_time+extra_time;
                     if(lo==0&&save_res&&(time(NULL)-time_of_last_save>=seconds_per_save||guess>=max_wall_time))
                        {gettimeofday(&start,NULL);
                         if(d2!=0)cnt=si2+j;
                         else     cnt=off;         
                         save_stage2_res(fp,l2,nt);save_stage2(d,d2,i,j,k,si,cnt,nt);time_of_last_save=time(NULL);
                         gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
			 dtime=(double)diff->secs+(double)diff->usecs/1000000.;
                         printf(" [output time=%lf sec. (Wall)]\n",dtime);
			 if((time_t)dtime>printingtime)printingtime=(time_t)dtime;
			 if(guess>=max_wall_time)check_time();
                         }
                     ido=time(NULL);
                 }
              }
              MPN_NORMALIZE(fp,l2);
              if(d2!=0) len2[off]=l2;
              else      ss(off,fp,l2,getpr(off,e));
              safe_free(inv2);
              safe_free(temp4);
              if(d2==0)safe_free(rx);
          }}
          spec=0;
      }
   
   return;
}

void fun2(lli stage2_offset,lli stage2_k,lli i,lli i2,lli numprimes,int d,int d2,int e,int lo,lli si,lli si2,int nt)  {
// 'a' is the array of primes, nt is the number of threads working here,  if lo=1, then not every thread is working here
// fast version of fun1: t=i/2^d ,here i2=imin(i+2^d-1,numprimes-1)
// set w=res[t]
// set temp2=prod(h=i,i2,a[h])^2
// for j from 0 to 2^(d-d2)-1:
//   if j!=0 then set w=(w*((a[s2]-1)/e)!/((a[s1]-1)/e)!) mod temp2 where s1=t*2^d+(j-1)*2^d2 and s2=t*2^d+j*2^d2
//   set res2[t*2^(d-d2)+j]=w mod temp4, where temp4=prod(h=t*2^d+j*2^d2,t*2^d+(j+1)*2^d2-1,a[h])^2

     int spec;
     lli i3,i4,i5,i6,j,k,k2,offset,start_k,pos,off,pow2,ppow2,m,n,t,t2,t3,t4,t5,t6,cnt,hi,*v;
     mp_size_t size,size2,size4,wsize;
     double dtime;
     struct timeval start,end;
     TIME_DIFF *diff;
   
     if(stage2_offset==-1){spec=0;offset=0;}
     else {spec=1;offset=stage2_offset;}
     
     n=1LL<<Depth;
     pow2=1LL<<d;
     ppow2=1LL<<(d-d2);
     
     t=getpos(i-1,numprimes,Depth);
     t2=getpos(i2,numprimes,Depth)-1;     
     v=safe_malloc((t2-t+1)*sizeof(lli));
     reconstruct(v,t,t2,e);
     m=get_num_limbs(v,0,t2-t);
     size=2*m+1+POWER2*(t2-t+1>POWER2);
     mp_limb_t *temp2=safe_malloc(size*sizeof(mp_limb_t));
     size2=prodtree2(temp2,v,0,t2-t,1,nt);
     ntt_mpn_mul_bonus(temp2,temp2,size2,0,temp2,size2,0,1,nt);
     size2*=2;
     if(temp2[size2-1]==ZERO)size2--;
     temp2[size2]=ZERO;
     size2=shift_m(temp2,size2,nt);
     mp_limb_t *inv=safe_malloc(size2*sizeof(mp_limb_t));
     mpn_setup_barrett(inv,temp2,size2,nt);
   
     pos=i/pow2;
     wsize=size2;
     mp_limb_t *w=(mp_limb_t*)(malloc)(wsize*sizeof(mp_limb_t));
     my_mpn_zero(w,wsize,nt);
     my_mpn_copyi(w,res[pos],len[pos],nt);
     wsize=len[pos];
     time_t guess,ido=time(NULL);
     time2=0;
     for(j=offset;j<ppow2;j++)  {
         i3=i+(j<<d2);
         i4=imin(n-1,i3+(1LL<<d2)-1);
         if(i3<=i4){
            t3=getpos(i3-1,numprimes,Depth);
            t4=getpos(i4,numprimes,Depth)-1;
            if(t3<=t4){
            v=safe_malloc((t4-t3+1)*sizeof(lli));
            reconstruct(v,t3,t4,e);
            m=get_num_limbs(v,0,t4-t3);
            size=2*m+1+POWER2*(t4-t3+1>POWER2);
            mp_limb_t *temp4=safe_malloc(size*sizeof(mp_limb_t));
            size4=prodtree2(temp4,v,0,t4-t3,1,nt);
            ntt_mpn_mul_bonus(temp4,temp4,size4,0,temp4,size4,0,1,nt);
            size4*=2;
            if(temp4[size4-1]==ZERO)size4--;
            temp4[size4]=ZERO;
            size4=shift_m(temp4,size4,nt);
            mp_limb_t *inv2=safe_malloc(size4*sizeof(mp_limb_t));
            mpn_setup_barrett(inv2,temp4,size4,nt);
  
            if(d2!=0)  off=(pos<<(d-d2))+j;
            else       off=getpos((pos<<(d-d2))+j-1,numprimes,Depth);

            if(j!=0)  {  
               i5=i+((j-1)<<d2);
               i6=i5+(1LL<<d2);
               t5=getpos(i5,numprimes,Depth)-1;
               t6=getpos(i6,numprimes,Depth)-1;
               if(spec&&j==offset){wsize=read_stage2_res(w,size2,nt);start_k=stage2_k;}
               else start_k=(getpr(t5,e)-1)/e+1;
               hi=(getpr(t6,e)-1)/e;
               for(k=start_k;k<=hi;){
                    k2=imin(hi,k+2*(t2-t+1)-1);
                    wsize=mpn_parallel_modproduct_tree(w,wsize,temp2,size2,inv,k,k2,nt);
                    k=k2+1;
		    ido=time(NULL)-ido;if(time2<ido)time2=ido;mod_time=time2;
		    guess=2*(time2+printingtime)+time(NULL)-start_time+extra_time;
                    if(lo==0&&save_res&&(time(NULL)-time_of_last_save>=seconds_per_save||guess>=max_wall_time))
                        {gettimeofday(&start,NULL);
                         if(d2!=0)cnt=si2+j;
                         else cnt=off;
                         save_stage2_res(w,wsize,nt);save_stage2(d,d2,i,j,k,si,cnt,nt);time_of_last_save=time(NULL);
                         gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
			 dtime=(double)diff->secs+(double)diff->usecs/1000000.;
                         printf(" [output time=%lf sec. (Wall)]\n",dtime);
			 if((time_t)dtime>printingtime)printingtime=(time_t)dtime;
			 if(guess>=max_wall_time)check_time();
                        }
                    ido=time(NULL);
               }
            }

            MPN_NORMALIZE(w,wsize);
            if(d2!=0)  {
               res2[off]=safe_malloc(size4*sizeof(mp_limb_t));
               len2[off]=longdivision(w,wsize,inv2,temp4,size4,res2[off],nt);
            }
            else ss(off,w,wsize,getpr(off,e));
    
            safe_free(inv2);
            safe_free(temp4);  
         }}
         spec=0;
     }
     safe_free(inv);
     safe_free(temp2);
     safe_free(w);
   
     return;
}

void parallel_func2(mp_size_t Qsize,lli* a,lli numprimes,int e,int stage2_depth,lli stage2_i,lli stage2_offset,lli stage2_k,int numthreads)  {
// routine of the 2nd stage to distribute the works to fun1/fun2   
   int numth=omp_get_max_threads();
   int d,d2,depth2,lo,nt,sub,spec,*done,th_id;
   lli cnt,i,i2,j,k,offset,pow2,n,si,si2,ST,up,last_i[numth];
   unsigned long long int ui;
   char name[100];
   double dtime;
   time_t guess;
   struct timeval start,end;
   TIME_DIFF *diff;
   
   depth2=0,pow2=1;while(pow2!=SPOWER2)pow2<<=1,depth2++;
   Depth=0;pow2=1;while(pow2<numprimes)pow2<<=1,Depth++;

   if(stage2_depth==-1){
     spec=0;
     stage2_depth=Depth;
     ST=0;
     res=safe_malloc(1*sizeof(mp_limb_t*));
     res[0]=safe_malloc(Qsize*sizeof(mp_limb_t));
     my_mpn_copyi(res[0],Q,Qsize,numthreads);
     safe_free(Q);
     len=safe_malloc(1*sizeof(lli));
     len[0]=Qsize;
     spec=0;
   }
   else {spec=1;ST=stage2_i;}
   
   si=(numprimes+31)/32;
   si2=(numprimes+1)/2;
   firstp=safe_malloc(si*sizeof(lli));
   diffp=safe_malloc(si2*sizeof(unsigned int));
   for(i=0;i<numprimes;i+=32)firstp[i>>5]=a[i];
   for(i=0;i<si2;i++)diffp[i]=0;
   for(i=0;i<numprimes;i++){
      if(i==0)ui=0;
      else    ui=(a[i]-a[i-1])/e;
      max_ui=imax(max_ui,ui);
      assert(ui<65536);
      diffp[i>>1]+=ui<<(16*(i&1));
   }
   safe_free(a);
   a=NULL;
   existplist=0;
   
   n=1LL<<Depth;
   
   for(d=stage2_depth;d>=0;)  {
       
       if(d==Depth)sub=ext_depth;
       else if(d>Depth-depth2)sub=3;
       else {sub=d%step_depth;if(sub==0)sub=step_depth;}
     
       d2=imax(0,d-sub);
       pow2=1LL<<d;
       if(d<=Depth-depth2){nt=1;lo=1;}
       else {nt=numthreads;lo=0;}
       
       si2=n>>d2;
       si=n>>d;
       
       done=safe_malloc(si*sizeof(int));
       
       if(d2!=0)  {
          res2=safe_malloc(si2*sizeof(mp_limb_t*));
          len2=safe_malloc(si2*sizeof(lli));
       }
       else  {RES=safe_malloc(2*numprimes*sizeof(mp_limb_t));my_mpn_zero(RES,2*numprimes,numthreads);}
       
       if(spec){// read stored stage2 residues
         res=safe_malloc(si*sizeof(mp_limb_t*));
         len=safe_malloc(si*sizeof(lli));
         
         gettimeofday(&start,NULL);
         FILE* in;
         sprintf(name,"parallelwilsontemp%d.txt",stage2_f21);
         in=fopen(name,"rb");
         read_mpn_array(in,si,0,numthreads);
         fclose(in);
     
         sprintf(name,"parallelwilsontemp%d.txt",stage2_f22);
         in=fopen(name,"rb");
         
         if(d2==0)                  cnt=getpos(stage2_i-1,numprimes,Depth);
         else if(stage2_offset!=-1) cnt=(stage2_i>>d2)+stage2_offset;
         else                       cnt=(imin(n-1,stage2_i-1)>>d2)+1;
         read_mpn_array(in,cnt,1+(d2==0),numthreads);
         gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
         printf(" [input time=%lf sec. (Wall)]\n",(double)diff->secs+(double)diff->usecs/1000000.);
         fclose(in);
       }
       
       if(nt==1){
	  time_t ido[numth],maxtime[numth];
	  for(i=0;i<numth;i++)maxtime[i]=0;
	  
          up=ST/pow2;
          for(i=0;i<si;i++)done[i]=(i<up);
          for(i=0;i<numth;i++)last_i[i]=0;
          #pragma omp parallel for schedule(dynamic) private(cnt,i2,guess,j,k,offset,th_id,time2)
          for(i=ST;i<n;i+=pow2)  {
              th_id=omp_get_thread_num();
	      ido[th_id]=time(NULL);
	      
              i2=imin(n-1,i+pow2-1);
              if(d2!=0) cnt=(i>>d2);
              else      cnt=getpos(i-1,numprimes,Depth);
              if(spec&&i==ST){offset=stage2_offset;k=stage2_k;}
              else           {offset=-1;k=-1;}
              if(d==Depth)fun1(offset,k,i,i2,numprimes,d,d2,e,lo,si,cnt,nt);
              else        fun2(offset,k,i,i2,numprimes,d,d2,e,lo,si,cnt,nt);
      
              if(d2!=0) cnt=(i2>>d2)+1;
              else      cnt=getpos(i2,numprimes,Depth);
	      
	      ido[th_id]=time(NULL)-ido[th_id];
	      if(ido[th_id]>maxtime[th_id])maxtime[th_id]=ido[th_id];
	      time2=0;
	      for(j=0;j<numth;j++)if(time2<maxtime[j])time2=maxtime[j];
	      guess=2*(time2+printingtime)+time(NULL)-start_time+extra_time;
	      
              if(save_res&&(time(NULL)-time_of_last_save>=seconds_per_save||guess>=max_wall_time))
                 {offset=last_i[th_id];while(done[offset])offset++;last_i[th_id]=offset;
                  if(offset==i/pow2&&(time(NULL)-time_of_last_save>=seconds_per_save||guess>=max_wall_time)){// re-check the time
                    gettimeofday(&start,NULL);
                    save_stage2(d,d2,i+pow2,-1,-1,si,cnt,nt);
                    gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
                    time_of_last_save=time(NULL);
		    dtime=(double)diff->secs+(double)diff->usecs/1000000.;
                    printf(" [output time=%lf sec. (Wall)]\n",dtime);
		    if((time_t)dtime>printingtime)printingtime=(time_t)dtime;
		    if(guess>=max_wall_time)check_time();
                    }}
              done[i/pow2]=1;
          }
       }
       else  {
	 time2=0;mod_time=0;
	 time_t ido;
         for(i=ST;i<n;i+=pow2){
	     ido=time(NULL);
             i2=imin(n-1,i+pow2-1);
             if(spec&&i==ST){offset=stage2_offset;k=stage2_k;}
             else           {offset=-1;k=-1;}
             if(d2!=0)  cnt=(i>>d2);
             else       cnt=getpos(i-1,numprimes,Depth);
             if(d==Depth)fun1(offset,k,i,i2,numprimes,d,d2,e,lo,si,cnt,nt);
             else        fun2(offset,k,i,i2,numprimes,d,d2,e,lo,si,cnt,nt);
             
             if(d2!=0)  cnt=(i2>>d2)+1;
             else       cnt=getpos(i2,numprimes,Depth);
	     
	     ido=time(NULL)-ido;if(i==ST||time2<ido)time2=ido;
	     guess=2*(mod_time+printingtime)+time(NULL)-start_time+extra_time;
             if(save_res&&(time(NULL)-time_of_last_save>=seconds_per_save||guess>=max_wall_time))
	        {gettimeofday(&start,NULL);
                save_stage2(d,d2,i+pow2,-1,-1,si,cnt,nt);time_of_last_save=time(NULL);
                gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
	        dtime=(double)diff->secs+(double)diff->usecs/1000000.;
                printf(" [output time=%lf sec. (Wall)]\n",dtime);
	        if((time_t)dtime>printingtime)printingtime=(time_t)dtime;
		if(guess>=max_wall_time)check_time(); 
                }
         }
       }
       safe_free(done);
       safe_free(len);
       for(i=0;i<si;i++)safe_free(res[i]);safe_free(res);
       
       spec=0;
       ST=0;
       d=d2;
       if(d==0)break;
       
       res=safe_malloc(si2*sizeof(mp_limb_t*));
       for(i=0;i<si2;i++)  {
          MPN_NORMALIZE(res2[i],len2[i]);
          res[i]=safe_malloc(len2[i]*sizeof(mp_limb_t));
          my_mpn_copyi(res[i],res2[i],len2[i],numthreads);
          safe_free(res2[i]);
       }
       safe_free(res2);
       len=safe_malloc(si2*sizeof(lli));
       for(i=0;i<si2;i++)len[i]=len2[i];
       safe_free(len2);
   }
   safe_free(firstp);
   safe_free(diffp);
   
   return;
}

mp_size_t mpn_parallel_modproduct_tree(mp_limb_t* r,mp_size_t rsize,mp_limb_t* m,mp_size_t Msize,mp_limb_t *inv,lli pos1,lli pos2,int numthreads){
// compute r=(r*prod(i=pos1,pos2,i))%m
// assume that prod(i=pos1,pos2,i)<m
// return value is the number of limbs of the result
// assume that M is already shifted for Barrett1 method
    
    MPN_NORMALIZE(r,rsize);
    if(pos1>pos2)return rsize;
    
    lli ct=pos2-pos1+1,j,*S;
    mp_limb_t *temp;
    mp_size_t size;
   
    size=2*Msize+POWER2*(ct>POWER2);
    
    temp=safe_malloc(size*sizeof(mp_limb_t));
    S=safe_malloc(ct*sizeof(lli));
    for(j=0;j<ct;j++)S[j]=pos1+j;         
    size=prodtree2(temp,S,0,ct-1,1,numthreads);

    ntt_mpn_mul_bonus(temp,temp,size,0,r,rsize,0,1,numthreads);
    size+=rsize;
    MPN_NORMALIZE(temp,size);
    my_mpn_zero(temp+size,2*Msize-size,numthreads); 
    mpn_barrett1(r,temp,inv,m,Msize,numthreads);
    
    size=Msize;
    MPN_NORMALIZE(r,size);

    return size;
}

void stage3(lli pos1,lli pos2,int offset,int e)  {
     
     if(pos1>pos2)return;
  
     int euler_e=eulerphi(e);
     lli i;
     mpz_t a,p,r,t,x;
     mp_ptr fp;
     
     mpz_init(a);
     mpz_init(p);
     mpz_init(r);
     mpz_init(t);
     mpz_init(x);
     MPZ_REALLOC(a,2);
     SIZ(a)=2;
     
     for(i=pos1;i<=pos2;i++)  {
       
         longlongtompz(p,plist[i]);
         if(e!=2)ratio(x,plist[i],euler_e,e);
         fp=PTR(a);
         mpn_copyi(fp,RES+2*i,2);
         use_ratio(r,plist[i],euler_e,e,x,a);// if e=2, then here the X value is not used.
         
         if(printtofile)  {
            mpz_set(saved_p2[offset][i-pos1],p);
            mpz_set(saved_r2[offset][i-pos1],r);
         }
         
         mpz_add_ui(r,r,1); 
         assert(mpz_divisible_p(r,p)!=0);

         mpz_divexact(r,r,p);
         if(mpz_cmp(r,p)>=0)mpz_sub(r,r,p);
         mpz_fdiv_q_ui(t,p,denom);
         if(mpz_cmp_ui(t,bound)<0)mpz_set_ui(t,bound);
         if(mpz_cmp(r,t)>0)mpz_sub(r,r,p);
         if(mpz_cmpabs(r,t)<=0)  {// interesting result, save the result, output later to avoid parallel output to the same file
            mpz_set(saved_p[offset][numsol[offset]],p);
            mpz_set(saved_r[offset][numsol[offset]],r);
            numsol[offset]++;
         }
     }
     mpz_clear(a);
     mpz_clear(p);
     mpz_clear(r);
     mpz_clear(t);
     mpz_clear(x);
     
     return;
}

void printwilson(int cores)  {
  
    int i,j;
    FILE *out;
    out=fopen("wilson.txt","a+");
    
    for(i=0;i<cores;i++)
       for(j=0;j<numsol[i];j++)  {
            gmp_fprintf(out,"%Zd -1",saved_p[i][j]);
            if(mpz_sgn(saved_r[i][j])>=0)  fprintf(out,"+");
            else                           fprintf(out,"-");
            mpz_abs(saved_r[i][j],saved_r[i][j]);
            gmp_fprintf(out,"%Zdp\n",saved_r[i][j]);
       }
    fclose(out);   
    
    return;
}

void printallres(int cores)  {
  
   int i,j;
   FILE* out;
   out=fopen("wilsonres.txt","a+");
   
   for(i=0;i<cores;i++)
       for(j=0;j<numsol2[i];j++)gmp_fprintf(out,"%Zd %Zd\n",saved_p2[i][j],saved_r2[i][j]);
   fclose(out);
   
   return;
}

void printtime(void)  {
   
   time_t rawtime;
   struct tm * timeinfo;
   
   time(&rawtime);
   timeinfo=localtime(&rawtime);
   printf("Saved residues at %s",asctime(timeinfo));
   fflush(stdout);

   return;
}

void usesavefile(void)  {
    
    FILE *in,*out;
    char w[100];
        
    in=fopen("pwtimes.txt","r");
    out=fopen("pwtimes2.txt","w");
    
    if(in!=NULL)  {
       while(fscanf(in,"%s",w)!=EOF)
             fprintf(out,"%s\n",w);
    
       fclose(in);
       fclose(out);
    }
    
    in=fopen("parallelwilsonwork.txt","r");
    out=fopen("parallelwilsonwork2.txt","w");
    
    while(fscanf(in,"%s",w)!=EOF)
          fprintf(out,"%s\n",w);
    fprintf(out,"x\n");
    
    fclose(in);
    fclose(out);
    
    return;
}

void updatesavefile(void)  {
    
    int i,ct=0;
    FILE *in,*out;
    char w[32][100];
    
    in=fopen("parallelwilsonwork2.txt","r");

    while(ct<32&&fscanf(in,"%s",w[ct])!=EOF)ct++;
    
    if(ct==20&&strcmp(w[19],"x")==0){
       out=fopen("parallelwilsonwork.txt","w");
       for(i=0;i<19;i++)
          fprintf(out,"%s\n",w[i]);
       fclose(in);
       fclose(out);
       
       char u[100];
       in=fopen("pwtimes2.txt","r");
       if(in!=NULL)  {
          out=fopen("pwtimes.txt","w");
          while(fscanf(in,"%s",u)!=EOF)
                fprintf(out,"%s\n",u);
          fclose(in);
          fclose(out);
       }
    }
    else printf("Broken save file, use the original...\n");
    
    fclose(in);
    remove("parallelwilsonwork2.txt");
    remove("pwtimes2.txt");
}

void updatetimes(void)  {
  
    FILE* f;
    f=fopen("pwtimes.txt","w");
    fprintf(f,"used_stage_cpu_clock_time=%.0lf\n",(double)(clock()-start_stage_cpu_clock_time)/CLOCKS_PER_SEC+(double)used_stage_cpu_clock_time);
    fprintf(f,"used_stage_wall_time=%ld\n",time(NULL)-start_stage_wall_time+used_stage_wall_time);
    double cl=(double) clock()/CLOCKS_PER_SEC+(double)used_cpu_clock_time;
    time_t wa=time(NULL)-start_time+used_wall_time;
    fprintf(f,"used_cpu_clock_time=%.0lf\n",cl);
    fprintf(f,"used_wall_time=%ld\n",wa);
    fclose(f);

    return;
}

void save_stage1(int stage1_depth,lli stage1_q,mp_limb_t* a1,mp_limb_t* a0,mp_size_t size,int numthreads)  {

    int e,i;
    lli n;
    char w[19][100],name[100];
    FILE* f;

    f=fopen("parallelwilsonwork.txt","r");    
    for(i=0;i<19;i++)fscanf(f,"%s",w[i]);
    fclose(f);
    
    sscanf(w[1],"n=%lld",&n);
    sscanf(w[2],"e=%d",&e);
    
    stage1_f1=1-stage1_f1;
    sprintf(name,"parallelwilsontemp%d.txt",stage1_f1);remove(name);
    f=fopen(name,"wb");
    write_mpn(f,a1,size,numthreads);
    write_mpn(f,a0,size,numthreads);
    //gmp_fprintf(f,"%zd %Nx\n%zd %Nx\n",size,a1,size,size,a0,size);
    fclose(f);
    
    usesavefile();
    f=fopen("parallelwilsonwork.txt","w");
    for(i=0;i<6;i++)fprintf(f,"%s\n",w[i]);
    fprintf(f,"stage=1\nstage1_depth=%d\nstage1_q=%lld\nstage1_f1=%d\n",stage1_depth,stage1_q,stage1_f1);
    for(i=10;i<19;i++)fprintf(f,"%s\n",w[i]);
    fclose(f);
    updatetimes();
    remove("pwtimes2.txt");
    remove("parallelwilsonwork2.txt");
    
    for(i=0;i<10;i++){
        sprintf(name,"parallelwilsontemp%d.txt",i);
        if(i!=stage1_f1)remove(name);
    }
    
    printf("1st stage: %.2lf%c complete; ",100.0*get_ratio_stage1(n/e,stage1_depth,stage1_q),'%');
    get_more_info();
    printtime();
    
    return;
}

mp_size_t read_stage2_res(mp_limb_t *r,mp_size_t size,int numthreads)  {
    
    lli si;
    char name[100];
    FILE* f;
    
    my_mpn_zero(r,size,numthreads);

    sprintf(name,"parallelwilsontemp%d.txt",stage2_f23);
    f=fopen(name,"rb");
    fscanf(f,"%lld",&si);
    read_mpn(f,r,si,numthreads);
    fclose(f);
    
    return size;
}

void save_stage2_res(mp_limb_t *r,mp_size_t rsize,int numthreads)  {
    
    int f1=stage1_f1,f21=stage2_f21,f22=stage2_f22,f23=stage2_f23,f3=stage3_f3,used[10]={1,1,0,0,0,0,0,0,0,0};
    char name[100];
    FILE* f;
    
    if(f1>=0)used[f1]=1;
    if(f21>=0)used[f21]=1;
    if(f22>=0)used[f22]=1;
    if(f23>=0)used[f23]=1;
    if(f3>=0)used[f3]=1;     
    f23=0;
    while(used[f23])f23++;used[f23]=1;
    stage2_f23=f23;
     
    sprintf(name,"parallelwilsontemp%d.txt",f23);
    f=fopen(name,"wb");
    //gmp_fprintf(f,"%zd %Nx\n",rsize,r,rsize);
    write_mpn(f,r,rsize,numthreads);
    fclose(f);
     
    return;
}

void save_stage2(int stage2_depth,int d2,lli stage2_i,lli stage2_offset,lli stage2_k,lli si,lli si2,int numthreads)  {
   
    int i,depth,f1=stage1_f1,f21=stage2_f21,f22=stage2_f22,f23=stage2_f23,f3=stage3_f3,g21,g22,used[10]={1,1,0,0,0,0,0,0,0,0};
    char w[19][100],name[100];
    FILE* f;

    f=fopen("parallelwilsonwork.txt","r");
    for(i=0;i<19;i++)fscanf(f,"%s",w[i]);
    fclose(f);
    
    sscanf(w[13],"stage2_depth=%d",&depth);
    
    if(f1>=0)used[f1]=1;
    if(f21>=0)used[f21]=1;
    if(f22>=0)used[f22]=1;
    if(f23>=0)used[f23]=1;
    if(f3>=0)used[f3]=1;
    
    if(depth!=stage2_depth)  {
       g21=0;while(used[g21])g21++;used[g21]=1;
       sprintf(name,"parallelwilsontemp%d.txt",g21);
       f=fopen(name,"wb");
       write_mpn_array(f,si,0,numthreads);
       fclose(f);
    }
    else g21=f21;
    
    g22=0;while(used[g22])g22++;used[g22]=1;
    stage2_f21=g21;
    stage2_f22=g22;
    
    sprintf(name,"parallelwilsontemp%d.txt",g22);
    f=fopen(name,"wb");
    write_mpn_array(f,si2,1+(d2==0),numthreads);
    fclose(f);
    
    usesavefile();
    f=fopen("parallelwilsonwork.txt","w");
    for(i=0;i<6;i++)fprintf(f,"%s\n",w[i]);
    fprintf(f,"stage=2\n");
    for(i=7;i<10;i++)fprintf(f,"%s\n",w[i]);
    fprintf(f,"stage2_f21=%d\nstage2_f22=%d\nstage2_f23=%d\nstage2_depth=%d\nstage2_i=%lld\nstage2_offset=%lld\nstage2_k=%lld\n",stage2_f21,stage2_f22,stage2_f23,stage2_depth,stage2_i,stage2_offset,stage2_k);
    for(i=17;i<19;i++)fprintf(f,"%s\n",w[i]);
    fclose(f);
    updatetimes();
    remove("pwtimes2.txt");
    remove("parallelwilsonwork2.txt");
    
    for(i=0;i<10;i++){
        sprintf(name,"parallelwilsontemp%d.txt",i);
        if(i!=stage2_f21&&i!=stage2_f22&&i!=stage2_f23)remove(name);
    }
    
    get_more_info();
    printtime();
    
    return;
}

void save_stage3_first(lli numprimes)  {
    
    int i,r,used[10]={1,1,0,0,0,0,0,0,0,0};
    char name[100],w[19][100];
    FILE* f;
    
    if(stage1_f1>=0)used[stage1_f1]=1;   
    if(stage2_f21>=0)used[stage2_f21]=1;
    if(stage2_f22>=0)used[stage2_f22]=1;
    if(stage2_f23>=0)used[stage2_f23]=1;
    if(stage3_f3>=0)used[stage3_f3]=1;
    r=0;
    while(used[r])r++;
    stage3_f3=r;
    
    sprintf(name,"parallelwilsontemp%d.txt",stage3_f3);
    f=fopen(name,"wb");
    write_mpn_array(f,numprimes,2,1);
    fclose(f);
    
    usesavefile();
    f=fopen("parallelwilsonwork.txt","r");    
    for(i=0;i<19;i++)fscanf(f,"%s",w[i]);
    fclose(f);
    f=fopen("parallelwilsonwork.txt","w");    
    for(i=0;i<6;i++)fprintf(f,"%s\n",w[i]);
    fprintf(f,"stage=3\n");
    for(i=7;i<17;i++)fprintf(f,"%s\n",w[i]);
    fprintf(f,"stage3_f3=%d\nstage3_i=0\n",stage3_f3);
    fclose(f);
    start_stage_wall_time=time(NULL);
    used_stage_wall_time=0;
    start_stage_cpu_clock_time=clock();
    used_stage_cpu_clock_time=0;
    updatetimes();
    remove("pwtimes2.txt");
    remove("parallelwilsonwork2.txt");
    
    for(i=0;i<10;i++){
        sprintf(name,"parallelwilsontemp%d.txt",i);
        if(i!=stage3_f3)remove(name);
    }
    
    get_more_info();
    printtime();
    
    return;
}

void save_stage3(lli stage3_i)  {

    int i;
    char w[19][100],name[100];
    FILE* f;

    f=fopen("parallelwilsonwork.txt","r");    
    for(i=0;i<19;i++)fscanf(f,"%s",w[i]);
    fclose(f);
    
    usesavefile();
    f=fopen("parallelwilsonwork.txt","w");
    for(i=0;i<6;i++)fprintf(f,"%s\n",w[i]);
    fprintf(f,"stage=3\n");
    for(i=7;i<18;i++)fprintf(f,"%s\n",w[i]);
    fprintf(f,"stage3_i=%lld\n",stage3_i);
    fclose(f);
    updatetimes();
    remove("pwtimes2.txt");
    remove("parallelwilsonwork2.txt");
    
    for(i=0;i<10;i++)  {
       sprintf(name,"parallelwilsontemp%d.txt",i);
       if(i!=stage3_f3)remove(name);
    }

    get_more_info();
    printtime();
    
    return;
}

void read_stage3(lli numprimes)  {
    
    int i;
    RES=safe_malloc(2*numprimes*sizeof(mp_limb_t));
    mp_limb_t *x=safe_malloc(2*sizeof(mp_limb_t));
    char name[100];
    FILE* f;
    
    sprintf(name,"parallelwilsontemp%d.txt",stage3_f3);
    f=fopen(name,"rb");
    read_mpn_array(f,numprimes,2,1);
    fclose(f);
    
    for(i=0;i<10;i++)  {
       sprintf(name,"parallelwilsontemp%d.txt",i);
       if(i!=stage3_f3)remove(name);
    }
    safe_free(x);
    
    return;
}

void get_more_info(void)  {
#ifdef __unix__
     long long int m;
     char name[100],line[2048];
     FILE* in;

     sprintf(name,"/proc/%d/status",getpid());
     //printf("pid=%d\n",getpid());

     in=fopen(name,"r");
     if(in!=NULL){
        while(fgets(line,2048,in)!=0){
             if(!strncmp(line,"VmPeak:",7))
                {sscanf(line,"%*s %lld %*s",&m);printf("VmPeak: %.2lf Gbytes; ",(double)m/1048576);}
             else if(!strncmp(line,"VmHWM:",6))
                {sscanf(line,"%*s %lld %*s",&m);printf("VmHWM: %.2lf Gbytes; ",(double)m/1048576);}
             else if(!strncmp(line,"VmRSS:",6))
                {sscanf(line,"%*s %lld %*s",&m);printf("VmRSS: %.2lf Gbytes; ",(double)m/1048576);}
             else if(!strncmp(line,"VmSize:",7))
                {sscanf(line,"%*s %lld %*s",&m);printf("VmSize: %.2lf Gbytes; ",(double)m/1048576);}
        }
     }
     fclose(in);
#endif
     
     printf("CPU time used: %.0lf sec.; Wall clock time passed: %ld sec.; ",(double) clock()/CLOCKS_PER_SEC,time(NULL)-start_time);
     fflush(stdout);
     return;
}

double approx_prime_pi(lli n)  {
// get a quick approximation for primepi(n)
   if(n<2)return 0.0;
   
   return (double) n/(log(n)-1.0);
}

double get_ratio_stage1(lli n,int depth,lli q)  {
   
   int d;
   lli c,i,n1=0,n2=0,pow2;

   d=0;pow2=1;
   while(pow2<n)pow2<<=1,d++;
   
   for(;d>=0;d--){      
      for(i=((1LL)<<d);i*i<n&&i<10000;i++)// Check the [n/(i+1),n/i) interval
          if((i>>d)&1){
             c=imax(0,approx_prime_pi(n/i)-approx_prime_pi(n/(i+1)));
             n2+=c;
             // check if we processed this interval (or partly) or not
             if(d>depth||(d==depth&&n/i<q))n1+=c;
             else if(d==depth&&n/(i+1)<=q&&q<=n/i)
                  n1+=imax(0,approx_prime_pi(q)-approx_prime_pi(n/(i+1)));
         }
   }
   return (double) n1/imax(1,n2);
}

void check_time(void)  {
  
   printf("The program shortly exceeds the given Wall time. Exit.\n");
   fflush(stdout);
   exit(3);
}


int main()  {

   start_time=time(NULL);
   assert(sizeof(int)>=4&&sizeof(lli)>=8&&POWER2>=2&&(POWER2&(POWER2-1))==0&&(SPOWER2&(SPOWER2-1))==0&&step_depth>0&&ext_depth>0);

   // printf("%lld\n",getpos((1LL<<24)-1,20000000,25));
   
   ntt_init();
   inits();

   // test_barrett1();
   // test_longdivision();
   // testfun();
   // timings_of_pol_gcd();
   // find_opt_bounds();
   
   // printf("GMP version: %d.%d.%d\n",__GNU_MP_VERSION,__GNU_MP_VERSION_MINOR,__GNU_MP_VERSION_PATCHLEVEL);

   int cores,e,euler_e,stage,stage1_depth,stage2_depth,u,updated;
   lli fst,i,i1,i2,j,ll_st,ll_en,numprimes,stage1_q,stage2_i,stage2_offset,stage2_k,stage3_i;
   double dtime;
   FILE *in,*out;
   time_t sec,sec2;
   struct timeval start,end;
   TIME_DIFF *diff;
   mp_size_t size;
   mpz_t st,en,n,temp;
   mpz_init(st);
   mpz_init(en);
   mpz_init(n);
   mpz_init(temp);
   
   stage=0;
   stage1_depth=-1;
   stage1_q=0;
   stage1_f1=0;
   stage2_f21=-1;
   stage2_f22=-1;
   stage2_f23=-1;
   stage2_depth=-1;
   stage2_i=0;
   stage2_offset=-1;
   stage2_k=-1;
   stage3_f3=-1;
   stage3_i=0;
   printtofile=0;
   save_res=0;
   used_stage_cpu_clock_time=0;
   used_stage_wall_time=0;
   used_cpu_clock_time=0;
   used_wall_time=0;

   // for(i=0;i<30;i++)printf("for e=%d the treshold is %lld\n",allowed_even_e_values[i],treshold_for_e[i]);
 
   // comment out to use wilsonremainder()
   // while(gmp_scanf("%Zd",&n)!=EOF){sec=time(NULL);wilsonremainder(temp,n);gmp_printf("wilson(%Zd)=%Zd,time=%ld sec.\n",n,temp,time(NULL)-sec);}

   int maxthreads=omp_get_max_threads();
   printf("Found %d core(s) on this computer.\n",maxthreads);
   printf("Please give the number of availables core(s) for this code! ");scanf("%d",&cores);
   assert(cores>=0&&cores<=maxthreads);
   if(cores==0)return 0;
   omp_set_num_threads(cores);
   
   int ans=0,ans2=0;
   
   // safetey check
   in=fopen("parallelwilsonwork2.txt","r");
   if(in!=NULL){printf("warning: killed the code during file output, use an earlier save file...\n");updatesavefile();}
   
   in=fopen("parallelwilsonwork.txt","r");
   if(in!=NULL)  {
      printf("Found unfinished work, would you like to continue it? (0/1) ");scanf("%d",&ans);
      if(ans!=0)  {
        gmp_fscanf(in,"st=%Zd-en=%Zd\n",st,en);
        gmp_fscanf(in,"n=%Zd\n",n);
        fscanf(in,"e=%d\n",&e);
        fscanf(in,"interval=%lld\n",&interval);
        fscanf(in,"printtofile=%d\n",&printtofile);
        fscanf(in,"save_res=%d\n",&save_res);
        fscanf(in,"stage=%d\n",&stage);
        fscanf(in,"stage1_depth=%d\n",&stage1_depth);
        fscanf(in,"stage1_q=%lld\n",&stage1_q);
        fscanf(in,"stage1_f1=%d\n",&stage1_f1);
        fscanf(in,"stage2_f21=%d\n",&stage2_f21);
        fscanf(in,"stage2_f22=%d\n",&stage2_f22);
        fscanf(in,"stage2_f23=%d\n",&stage2_f23);
        fscanf(in,"stage2_depth=%d\n",&stage2_depth);
        fscanf(in,"stage2_i=%lld\n",&stage2_i);
        fscanf(in,"stage2_offset=%lld\n",&stage2_offset);
        fscanf(in,"stage2_k=%lld\n",&stage2_k);
        fscanf(in,"stage3_f3=%d\n",&stage3_f3);
        fscanf(in,"stage3_i=%lld\n",&stage3_i);
        fclose(in);
	in=fopen("pwtimes.txt","r");
	if(in!=NULL){
	   fscanf(in,"used_stage_cpu_clock_time=%ld\n",&used_stage_cpu_clock_time);
  	   fscanf(in,"used_stage_wall_time=%ld\n",&used_stage_wall_time);
	   fscanf(in,"used_cpu_clock_time=%ld\n",&used_cpu_clock_time);
	   fscanf(in,"used_wall_time=%ld\n",&used_wall_time);
	   fclose(in);
	}

        gmp_printf("Would you like to use a new 'interval' from n=%Zd ? (0/1) ",n);scanf("%d",&ans2);
        if(ans2){
           printf("Give it: ");scanf("%lld",&interval);
           stage=0;
           stage1_depth=-1;
           stage1_q=0;
           stage1_f1=0;
           stage2_f21=-1;
           stage2_f22=-1;
           stage2_f23=-1;
           stage2_depth=-1;
           stage2_i=0;
           stage2_offset=-1;
           stage2_k=-1;
           stage3_f3=-1;
           stage3_i=0;
	   used_stage_cpu_clock_time=0;
	   used_stage_wall_time=0;
	   used_cpu_clock_time=0;
           used_wall_time=0;
        }
        gmp_printf("Continue the st=%Zd, en=%Zd search; process %lld primes at once; printtofile=%d.\n",st,en,interval,printtofile);
        gmp_printf("done p<%Zd, p==%d mod %d, the current search on interval is in stage=%d\n",n,1,e,stage);
     }
   }
   else printf("Not found unfinished workunit.\n");
    
   if(ans==0)  {
       printf("The allowed (even) e values are:\n");
       printf("2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,48,50,54,60,66,70,84,90\n");
       printf("Choose one: ");scanf("%d",&e);assert(valid_even_e(e));
       printf("Please give start and end value of the search! ");gmp_scanf("%Zd %Zd",st,en);
       printf("Give how many primes to process at once: ");scanf("%lld",&interval);
       printf("Do you want to print to file all residues (0/1)? (Warning large text file!): ");scanf("%d",&printtofile);
       printf("Would you like to use large savefile for frequent save (in approx. every %d seconds or before we exit) (0/1)? ",seconds_per_save);scanf("%d",&save_res);
       printf("All interesting residues in wilson.txt (res=-1+kp, where abs(k)<=max(%d,p/%d))\n",bound,denom);
    }
    
    printf("Give the Wall time you would like to spend on this run in seconds ! ");
    scanf("%ld",&max_wall_time);

    if(mpz_cmp_ui(st,3*e+1)<0)mpz_set_ui(st,3*e+1);// skip p<3*e+1, that means at most two primes: e+1 and 2*e+1
    u=0;while(allowed_even_e_values[u]!=e)u++;
    if(mpztolonglong(st)<treshold_for_e[u]&&test_all_primes_for_e==0)
       {longlongtompz(st,treshold_for_e[u]);gmp_printf("Updated st=%Zd\n",st);}
    if(mpz_cmp(st,en)>0) return 0;// trivial case

    assert(interval>0);
    assert(mpz_sizeinbase(en,2)<=61);
    
    printf("Precompute pow table.\n");setuppow1024();printf("done.\nAll precomputations are done, start the clock.\n");
    fflush(stdout);
    
    sec=time(NULL);
    time_of_last_save=time(NULL);

    sievelen=imax(64,3+(int)sqrt(mpztolonglong(en)));
    initprimes(sievelen);
    
    if(ans==0){
      i=mpz_fdiv_r_ui(temp,st,e);
      mpz_add_ui(n,st,(e+1-i)%e);
    }
    else assert(mpz_fdiv_r_ui(temp,n,e)==1);

    euler_e=eulerphi(e);
    init_tables(euler_e,e);

    ll_en=mpztolonglong(en);
    
    numsol=safe_malloc(cores*sizeof(int));
    saved_p=safe_malloc(cores*sizeof(mpz_t*));for(i=0;i<cores;i++)saved_p[i]=safe_malloc(maxsol*sizeof(mpz_t));
    for(i=0;i<cores;i++)for(j=0;j<maxsol;j++)mpz_init(saved_p[i][j]);
    saved_r=safe_malloc(cores*sizeof(mpz_t*));for(i=0;i<cores;i++)saved_r[i]=safe_malloc(maxsol*sizeof(mpz_t));
    for(i=0;i<cores;i++)for(j=0;j<maxsol;j++)mpz_init(saved_r[i][j]);
    
    if(printtofile){
       numsol2=safe_malloc(cores*sizeof(int));
       saved_p2=safe_malloc(cores*sizeof(mpz_t*));for(i=0;i<cores;i++)saved_p2[i]=safe_malloc(chunk_size*sizeof(mpz_t));
       for(i=0;i<cores;i++)for(j=0;j<chunk_size;j++)mpz_init(saved_p2[i][j]);
       saved_r2=safe_malloc(cores*sizeof(mpz_t*));for(i=0;i<cores;i++)saved_r2[i]=safe_malloc(chunk_size*sizeof(mpz_t));
       for(i=0;i<cores;i++)for(j=0;j<chunk_size;j++)mpz_init(saved_r2[i][j]);
    }
    updated=0;
    
    printingtime=0;
    time1=0;
    time2=0;
    time3=0;
    while(mpz_cmp(n,en)<=0)  {

       if(stage<=0&&updated==0){
          stage=0;

          remove("parallelwilsontemp0.txt");
          remove("parallelwilsontemp1.txt");
          remove("parallelwilsontemp2.txt");
          remove("parallelwilsontemp3.txt");
          remove("parallelwilsontemp4.txt");
          remove("parallelwilsontemp5.txt");
          remove("parallelwilsontemp6.txt");
          remove("parallelwilsontemp7.txt");
          remove("parallelwilsontemp8.txt");
          remove("parallelwilsontemp9.txt");
          out=fopen("parallelwilsonwork.txt","w");
          gmp_fprintf(out,"st=%Zd-en=%Zd\nn=%Zd\ne=%d\ninterval=%lld\nprinttofile=%d\nsave_res=%d\nstage=%d\n",st,en,n,e,interval,printtofile,save_res,stage);
          gmp_fprintf(out,"stage1_depth=%d\nstage1_q=%lld\nstage1_f1=%d\n",stage1_depth,stage1_q,stage1_f1);
          gmp_fprintf(out,"stage2_f21=%d\nstage2_f22=%d\nstage2_f23=%d\nstage2_depth=%d\nstage2_i=%lld\nstage2_offset=%lld\nstage2_k=%lld\n",stage2_f21,stage2_f22,stage2_f23,stage2_depth,stage2_i,stage2_offset,stage2_k);
          gmp_fprintf(out,"stage3_f3=%d\nstage3_i=%lld\n",stage3_f3,stage3_i);
          fclose(out);
          updatetimes();  
      }
       
       ll_st=mpztolonglong(n);
       numprimes=wheelsieve(e,ll_st,ll_en,cores);interval=imax(numprimes,interval);
       existplist=1;
       if(numprimes==0){safe_free(plist);plist=NULL;break;}

       gmp_printf("Testing p=%lld...%lld, p==%d mod %d, stage=%d, (%lld primes for that e=%d is the best) time=%ld sec.\n",plist[0],plist[numprimes-1],1,e,stage,numprimes,e,time(NULL)-sec);
       fflush(stdout);

       if(stage<=1)  {
	       sec2=time(NULL);
	       start_stage_wall_time=time(NULL);
	       start_stage_cpu_clock_time=clock();
               stage=1;
               size=POWER2+get_num_limbs(plist,0,numprimes-1);
               mp_limb_t *fp;
               fp=safe_malloc(size*sizeof(mp_limb_t));
               fst=(plist[0]-1)/e;
               size=prodtree2(fp,plist,0,numprimes-1,1,cores);
               existplist=0;

               fp[size]=ZERO;
               fp[size+1]=ZERO;
               size=ff(fp,size,fst,stage1_depth,stage1_q,cores);
               printf("Done the first stage in %ld sec., %.0lf sec. cpu clock time, found ((q-1)/e)! mod m^2, where q=%lld, e=%d, m=product of %lld primes\n",time(NULL)-sec2+used_stage_wall_time,(double) (clock()-start_stage_cpu_clock_time)/CLOCKS_PER_SEC+(double)used_stage_cpu_clock_time,fst*e+1,e,numprimes);
               fflush(stdout);
	       used_stage_wall_time=0;
	       used_stage_cpu_clock_time=0;
       }
         
       if(stage<=2)  {
              sec2=time(NULL);
	      start_stage_wall_time=time(NULL);
	      start_stage_cpu_clock_time=clock();
              if(!existplist){numprimes=wheelsieve(e,ll_st,ll_en,cores);existplist=1;}
              fst=(plist[0]-1)/e;
              stage=2;
              parallel_func2(size,plist,numprimes,e,stage2_depth,stage2_i,stage2_offset,stage2_k,cores);
              printf("Done the second stage in %ld sec., %.0lf sec. cpu clock time, computed %lld values of the form ((p-1)/e)!/((q-1)/e)! mod p^2, where q=%lld, e=%d\n",time(NULL)-sec2+used_stage_wall_time,(double) (clock()-start_stage_cpu_clock_time)/CLOCKS_PER_SEC+(double)used_stage_cpu_clock_time,numprimes,fst*e+1,e);
              fflush(stdout);
	      time_t guess=2*printingtime+time(NULL)-start_time+extra_time;
              if(save_res){
                 gettimeofday(&start,NULL);
                 save_stage3_first(numprimes);
                 gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
		 dtime=(double)diff->secs+(double)diff->usecs/1000000.;
                 printf(" [output time=%lf sec. (Wall)]\n",dtime);
		 if((time_t)dtime>printingtime)printingtime=(time_t)dtime;
		 if(guess>=max_wall_time)check_time();
              }
              used_stage_wall_time=0;
	      used_stage_cpu_clock_time=0;
        }

        sec2=time(NULL);
	start_stage_wall_time=time(NULL);
	start_stage_cpu_clock_time=clock();
        if(!existplist){numprimes=wheelsieve(e,ll_st,ll_en,cores);existplist=1;}
        if(stage==3){
           gettimeofday(&start,NULL);
           read_stage3(numprimes);
           gettimeofday(&end,NULL);diff=my_difftime(&start,&end);
           printf(" [input time=%lf sec. (Wall)]\n",(double)diff->secs+(double)diff->usecs/1000000.); 
        }
        stage=3;    

	time_t ido=time(NULL),guess;time3=0;
        for(i=stage3_i;i<numprimes;i+=(lli)cores*chunk_size){
            for(j=0;j<cores;j++)numsol[j]=0;
            #pragma omp parallel for schedule(dynamic,1) private(i1,i2)
            for(j=0;j<cores;j++){
                i1=i+(lli)j*chunk_size;
                i2=imin(numprimes-1,i1+chunk_size-1);
                if(printtofile)numsol2[j]=(int)((lli)i2-i1+1);
                stage3(i1,i2,j,e);
             }
             if(printtofile)printallres(cores);
             printwilson(cores);
	     ido=time(NULL)-ido;if(time3<ido)time3=ido;
	     guess=2*time3+time(NULL)-start_time+extra_time;
             if(save_res&&(time(NULL)-time_of_last_save>=seconds_per_save_stage3||guess>=max_wall_time)){
                save_stage3(i+(lli)cores*chunk_size);
                time_of_last_save=time(NULL);
		if(guess>=max_wall_time)check_time();
             }
             ido=time(NULL);
         }

         safe_free(RES);
         RES=NULL;
         longlongtompz(n,plist[numprimes-1]);
         mpz_add_ui(n,n,e);
         safe_free(plist);
         plist=NULL;
         existplist=0;

         stage=0;
         stage1_depth=-1;
         stage1_q=0;
         stage1_f1=0;
         stage2_f21=-1;
         stage2_f22=-1;
         stage2_f23=-1;
         stage2_depth=-1;
         stage2_i=0;
         stage2_offset=-1;
         stage2_k=-1;
         stage3_f3=-1;
         stage3_i=0;

         remove("parallelwilsontemp0.txt");
         remove("parallelwilsontemp1.txt");
         remove("parallelwilsontemp2.txt");
         remove("parallelwilsontemp3.txt");
         remove("parallelwilsontemp4.txt");
         remove("parallelwilsontemp5.txt");
         remove("parallelwilsontemp6.txt");
         remove("parallelwilsontemp7.txt");
         remove("parallelwilsontemp8.txt");
         remove("parallelwilsontemp9.txt");
         usesavefile();
         out=fopen("parallelwilsonwork.txt","w");
         gmp_fprintf(out,"st=%Zd-en=%Zd\nn=%Zd\ne=%d\ninterval=%lld\nprinttofile=%d\nsave_res=%d\nstage=%d\n",st,en,n,e,interval,printtofile,save_res,stage);
         gmp_fprintf(out,"stage1_depth=%d\nstage1_q=%lld\nstage1_f1=%d\n",stage1_depth,stage1_q,stage1_f1);
         gmp_fprintf(out,"stage2_f21=%d\nstage2_f22=%d\nstage2_f23=%d\nstage2_depth=%d\nstage2_i=%lld\nstage2_offset=%lld\nstage2_k=%lld\n",stage2_f21,stage2_f22,stage2_f23,stage2_depth,stage2_i,stage2_offset,stage2_k);
         gmp_fprintf(out,"stage3_f3=%d\nstage3_i=%lld\n",stage3_f3,stage3_i);
         fclose(out);
         updated=1;
	 time_t temp1=used_stage_wall_time;
	 time_t temp2=used_stage_cpu_clock_time;
	 used_stage_wall_time=0;
	 used_stage_cpu_clock_time=0;
	 updatetimes();
	 remove("pwtimes2.txt");
         remove("parallelwilsonwork2.txt");
         
         printf("Done the third stage in %ld sec., %.0lf sec. cpu clock time, computed the polynomial gcd's for e=%d.\n",time(NULL)-sec2+temp1,(double) (clock()-start_stage_cpu_clock_time)/CLOCKS_PER_SEC+(double)temp2,e);
         get_more_info();printf("\n");
         fflush(stdout);
   }
   gmp_printf("Done the st=%Zd-en=%Zd range. Time=%ld sec., %.0lf sec. cpu clock time\n",st,en,time(NULL)-start_time+used_wall_time,(double)clock()/CLOCKS_PER_SEC+(double)used_cpu_clock_time);
   fflush(stdout);
   out=fopen("wilsondone.txt","a+");gmp_fprintf(out,"Done the st=%Zd-en=%Zd range. p==1 mod %d\n",st,en,e);fclose(out);
   remove("parallelwilsonwork.txt");
   remove("pwtimes.txt");

   safe_free(numsol);
   for(i=0;i<cores;i++){for(j=0;j<maxsol;j++)mpz_clear(saved_p[i][j]);safe_free(saved_p[i]);}safe_free(saved_p);
   for(i=0;i<cores;i++){for(j=0;j<maxsol;j++)mpz_clear(saved_r[i][j]);safe_free(saved_r[i]);}safe_free(saved_r);
   if(printtofile){
      safe_free(numsol2);
      for(i=0;i<cores;i++){for(j=0;j<chunk_size;j++)mpz_clear(saved_p2[i][j]);safe_free(saved_p2[i]);}safe_free(saved_p2);
      for(i=0;i<cores;i++){for(j=0;j<chunk_size;j++)mpz_clear(saved_r2[i][j]);safe_free(saved_r2[i]);}safe_free(saved_r2);
   }
   
   safe_free(prime);
   mpz_clear(st);
   mpz_clear(en);
   mpz_clear(n);
   mpz_clear(temp);
   safe_free(pow1024);
   del();

   // printf("max consecutive prime difference / e was %lld\n",max_ui);
   return 0;
}
